<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stack</title>
      <link href="/p/2154386542.html"/>
      <url>/p/2154386542.html</url>
      
        <content type="html"><![CDATA[<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/decode-string/" target="_blank" rel="noopener">394. Decode String</a></p><p><a href="https://leetcode.com/problems/online-stock-span/" target="_blank" rel="noopener">901. Online Stock Span</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue</title>
      <link href="/p/3191623783.html"/>
      <url>/p/3191623783.html</url>
      
        <content type="html"><![CDATA[<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><h4 id="Find-minimum-maximum-in-sliding-windows"><a href="#Find-minimum-maximum-in-sliding-windows" class="headerlink" title="Find minimum/maximum in sliding windows"></a>Find minimum/maximum in sliding windows</h4><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/continuous-subarrays/" target="_blank" rel="noopener">2762. Continuous Subarrays</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math</title>
      <link href="/p/152415091.html"/>
      <url>/p/152415091.html</url>
      
        <content type="html"><![CDATA[<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h3><h4 id="Find-prime-numbers"><a href="#Find-prime-numbers" class="headerlink" title="Find prime numbers"></a>Find prime numbers</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_primes</span><span class="params">(n)</span>:</span></span><br><span class="line">    primes = [<span class="literal">True</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    primes[<span class="number">0</span>] = primes[<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    num = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> num * num &lt;= n:</span><br><span class="line">        <span class="keyword">if</span> primes[num]:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num * num, n + <span class="number">1</span>, num):</span><br><span class="line">                primes[i] = <span class="literal">False</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> primes</span><br></pre></td></tr></table></figure><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">172. Factorial Trailing Zeroes</a></p><p><a href="https://leetcode.com/problems/prime-pairs-with-target-sum/" target="_blank" rel="noopener">2761. Prime Pairs With Target Sum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/p/3625871473.html"/>
      <url>/p/3625871473.html</url>
      
        <content type="html"><![CDATA[<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/shortest-bridge/" target="_blank" rel="noopener">934. Shortest Bridge</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bit Manipulation</title>
      <link href="/p/331104930.html"/>
      <url>/p/331104930.html</url>
      
        <content type="html"><![CDATA[<h2 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h2><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p><code>n &amp;= (n - 1)</code> removes the last non-zero bit</p><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">137. Single Number II</a></p><p><a href="https://leetcode.com/problems/special-permutations/" target="_blank" rel="noopener">2741. Special Permutations</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Greedy</title>
      <link href="/p/1243693337.html"/>
      <url>/p/1243693337.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">678. Valid Parenthesis String</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Data-Intensive Applications</title>
      <link href="/p/2267105565.html"/>
      <url>/p/2267105565.html</url>
      
        <content type="html"><![CDATA[<h2 id="Chapter-1-Reliable-Scalable-and-Maintainable-Applications"><a href="#Chapter-1-Reliable-Scalable-and-Maintainable-Applications" class="headerlink" title="Chapter 1 Reliable, Scalable, and Maintainable Applications"></a>Chapter 1 Reliable, Scalable, and Maintainable Applications</h2><p>A data-intensive application is typically built from standard building blocks that provide commonly needed functionality. For example, many applications need to:</p><ul><li>Store data so that they, or another application, can find it again later (databases)</li><li>Remember the result of an expensive operation, to speed up reads (caches)</li><li>Allow users to search data by keyword or filter it in various ways (search indexes)</li><li>Send a message to another process, to be handled asynchronously (stream processing)</li><li>Periodically crunch a large amount of accumulated data (batch processing)</li></ul><p>In this chapter, we will start by exploring the fundamentals of what we are trying to achieve: <strong>reliable</strong>, <strong>scalable</strong>, and <strong>maintainable</strong> data systems.</p><p>In this book, we focus on three concerns that are important in most software systems:</p><p><strong>Reliability</strong></p><p>The system should continue to work correctly (performing the correct function at the desired level of performance) even in the face of adversity (hardware or software faults, and even human error). See “Reliability” on page 6.</p><p><strong>Scalability</strong></p><p>As the system grows (in data volume, traffic volume, or complexity), there should be reasonable ways of dealing with that growth. See “Scalability” on page 10.</p><p><strong>Maintainability</strong></p><p>Over time, many different people will work on the system (engineering and operations, both maintaining current behavior and adapting the system to new use cases), and they should all be able to work on it productively. See “Maintainability” on page 18.</p><a id="more"></a><h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><p>Everybody has an intuitive idea of what it means for something to be reliable or unreliable. For software, typical expectations include:</p><ul><li>The application performs the function that the user expected.</li><li>It can tolerate the user making mistakes or using the software in unexpected ways.</li><li>Its performance is good enough for the required use case, under the expected load and data volume.</li><li>The system prevents any unauthorized access and abuse.</li></ul><p>If all those things together mean “working correctly,” then we can understand reliability as meaning, roughly, “continuing to work correctly, even when things go wrong.”</p><p>Although we generally prefer tolerating faults over preventing faults, there are cases where prevention is better than cure (e.g., because no cure exists). This is the case with security matters, for example: if an attacker has compromised a system and gained access to sensitive data, that event cannot be undone. However, this book mostly deals with the kinds of faults that can be cured, as described in the following sections.</p><h4 id="Hardware-Faults"><a href="#Hardware-Faults" class="headerlink" title="Hardware Faults"></a>Hardware Faults</h4><p>Until recently, redundancy of hardware components was sufficient for most applications, since it makes total failure of a single machine fairly rare. As long as you can restore a backup onto a new machine fairly quickly, the downtime in case of failure is not catastrophic in most applications. Thus, multi-machine redundancy was only required by a small number of applications for which high availability was absolutely essential.</p><p>However, as data volumes and applications’ computing demands have increased, more applications have begun using larger numbers of machines, which proportionally increases the rate of hardware faults. Moreover, in some cloud platforms such as Amazon Web Services (AWS) it is fairly common for virtual machine instances to become unavailable without warning, as the platforms are designed to prioritize flexibility and elasticityi over single-machine reliability.</p><p>Hence there is a move toward systems that can tolerate the loss of entire machines, by using software fault-tolerance techniques in preference or in addition to hardware redundancy. Such systems also have operational advantages: a single-server system requires planned downtime if you need to reboot the machine (to apply operating system security patches, for example), whereas a system that can tolerate machine failure can be patched one node at a time, without downtime of the entire system (a rolling upgrade; see Chapter 4).</p><h4 id="Software-Errors"><a href="#Software-Errors" class="headerlink" title="Software Errors"></a>Software Errors</h4><p>There is no quick solution to the problem of systematic faults in software. Lots of small things can help: carefully thinking about assumptions and interactions in the system; thorough testing; process isolation; allowing processes to crash and restart; measuring, monitoring, and analyzing system behavior in production. If a system is expected to provide some guarantee (for example, in a message queue, that the number of incoming messages equals the number of outgoing messages), it can constantly check itself while it is running and raise an alert if a discrepancy is found.</p><h4 id="Human-Errors"><a href="#Human-Errors" class="headerlink" title="Human Errors"></a>Human Errors</h4><p>How do we make our systems reliable, in spite of unreliable humans? The best systems combine several approaches:</p><ul><li>Design systems in a way that minimizes opportunities for error. For example, well-designed abstractions, APIs, and admin interfaces make it easy to do “the right thing” and discourage “the wrong thing.” However, if the interfaces are too restrictive people will work around them, negating their benefit, so this is a tricky balance to get right.</li><li>Decouple the places where people make the most mistakes from the places where they can cause failures. In particular, provide fully featured non-production sandbox environments where people can explore and experiment safely, using real data, without affecting real users.</li><li>Test thoroughly at all levels, from unit tests to whole-system integration tests and manual tests. Automated testing is widely used, well understood, and especially valuable for covering corner cases that rarely arise in normal operation.</li><li>Allow quick and easy recovery from human errors, to minimize the impact in the case of a failure. For example, make it fast to roll back configuration changes, roll out new code gradually (so that any unexpected bugs affect only a small subset of users), and provide tools to recompute data (in case it turns out that the old computation was incorrect).</li><li>Set up detailed and clear monitoring, such as performance metrics and error rates. In other engineering disciplines this is referred to as telemetry. (Once a rocket has left the ground, telemetry is essential for tracking what is happening, and for understanding failures.) Monitoring can show us early warning signals and allow us to check whether any assumptions or constraints are being violated. When a problem occurs, metrics can be invaluable in diagnosing the issue.</li><li>Implement good management practices and training—a complex and important aspect, and beyond the scope of this book.</li></ul><h4 id="How-Important-Is-Reliability"><a href="#How-Important-Is-Reliability" class="headerlink" title="How Important Is Reliability?"></a>How Important Is Reliability?</h4><h3 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h3><h4 id="Describing-Load"><a href="#Describing-Load" class="headerlink" title="Describing Load"></a>Describing Load</h4><p>First, we need to succinctly describe the current load on the system; only then can we discuss growth questions (what happens if our load doubles?). Load can be described with a few numbers which we call load parameters. The best choice of parameters depends on the architecture of your system: it may be requests per second to a web server, the ratio of reads to writes in a database, the number of simultaneously active users in a chat room, the hit rate on a cache, or something else. Perhaps the average case is what matters for you, or perhaps your bottleneck is dominated by a small number of extreme cases.</p><h4 id="Describing-Performance"><a href="#Describing-Performance" class="headerlink" title="Describing Performance"></a>Describing Performance</h4><p>Once you have described the load on your system, you can investigate what happens when the load increases. You can look at it in two ways:</p><ul><li>When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected?</li><li>When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged?<br>Both questions require performance numbers, so let’s look briefly at describing the performance of a system.</li></ul><p><strong>Latency and response time</strong>: Latency and response time are often used synonymously, but they are not the same. The response time is what the client sees: besides the actual time to process the request (the service time), it includes network delays and queueing delays. Latency is the duration that a request is waiting to be handled—during which it is latent, awaiting service.</p><p><strong>Percentiles in Practice</strong>: High percentiles become especially important in backend services that are called multiple times as part of serving a single end-user request. Even if you make the calls in parallel, the end-user request still needs to wait for the slowest of the parallel calls to complete. It takes just one slow call to make the entire end-user request slow, as illustrated in Figure 1-5. Even if only a small percentage of backend calls are slow, the chance of getting a slow call increases if an end-user request requires multiple backend calls, and so a higher proportion of end-user requests end up being slow (an effect known as tail latency amplification).</p><p>If you want to add response time percentiles to the monitoring dashboards for your services, you need to efficiently calculate them on an ongoing basis. For example, you may want to keep a rolling window of response times of requests in the last 10 minutes. Every minute, you calculate the median and various percentiles over the values in that window and plot those metrics on a graph.</p><p>The naïve implementation is to keep a list of response times for all requests within the time window and to sort that list every minute. If that is too inefficient for you, there are algorithms that can calculate a good approximation of percentiles at minimal CPU and memory cost, such as forward decay, t-digest, or HdrHistogram. Beware that averaging percentiles, e.g., to reduce the time resolution or to combine data from several machines, is mathematically meaningless—the right way of aggregating response time data is to add the histograms.</p><h3 id="Maintainability"><a href="#Maintainability" class="headerlink" title="Maintainability"></a>Maintainability</h3><p>We can and should design software in such a way that it will hopefully minimize pain during maintenance, and thus avoid creating legacy software ourselves. To this end, we will pay particular attention to three design principles for software systems:</p><p><strong>Operability</strong></p><p>Make it easy for operations teams to keep the system running smoothly.</p><p><strong>Simplicity</strong></p><p>Make it easy for new engineers to understand the system, by removing as much complexity as possible from the system. (Note this is not the same as simplicity of the user interface.)</p><p><strong>Evolvability</strong></p><p>Make it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as extensibility, modifiability, or plasticity.</p><h4 id="Operability-Making-Life-Easy-for-Operations"><a href="#Operability-Making-Life-Easy-for-Operations" class="headerlink" title="Operability: Making Life Easy for Operations"></a>Operability: Making Life Easy for Operations</h4><p>Operations teams are vital to keeping a software system running smoothly. A good operations team typically is responsible for the following, and more:</p><ul><li><p>Monitoring the health of the system and quickly restoring service if it goes into a bad state</p></li><li><p>Tracking down the cause of problems, such as system failures or degraded performance</p></li><li><p>Keeping software and platforms up to date, including security patches</p></li><li><p>Keeping tabs on how different systems affect each other, so that a problematic change can be avoided before it causes damage</p></li><li><p>Anticipating future problems and solving them before they occur (e.g., capacity planning)</p></li><li><p>Establishing good practices and tools for deployment, configuration management, and more</p></li><li><p>Performing complex maintenance tasks, such as moving an application from one platform to another</p></li><li><p>Maintaining the security of the system as configuration changes are made</p></li><li><p>Defining processes that make operations predictable and help keep the production environment stable</p></li><li><p>Preserving the organization’s knowledge about the system, even as individual people come and go</p></li></ul><p>Good operability means making routine tasks easy, allowing the operations team to focus their efforts on high-value activities. Data systems can do various things to make routine tasks easy, including:</p><ul><li><p>Providing visibility into the runtime behavior and internals of the system, with good monitoring</p></li><li><p>Providing good support for automation and integration with standard tools</p></li><li><p>Avoiding dependency on individual machines (allowing machines to be taken down for maintenance while the system as a whole continues running uninterrupted)</p></li><li><p>Providing good documentation and an easy-to-understand operational model (“If I do X, Y will happen”)</p></li><li><p>Providing good default behavior, but also giving administrators the freedom to override defaults when needed</p></li><li><p>Self-healing where appropriate, but also giving administrators manual control over the system state when needed</p></li><li><p>Exhibiting predictable behavior, minimizing surprises</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> System Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Backtracking</title>
      <link href="/p/527416199.html"/>
      <url>/p/527416199.html</url>
      
        <content type="html"><![CDATA[<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">39. Combination Sum</a></p><p><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. Combination Sum II</a></p><p><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets</a></p><p><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">90. Subsets II</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Subsets</title>
      <link href="/p/2189758150.html"/>
      <url>/p/2189758150.html</url>
      
        <content type="html"><![CDATA[<h2 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">78. Subsets</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Tools</title>
      <link href="/p/3794759868.html"/>
      <url>/p/3794759868.html</url>
      
        <content type="html"><![CDATA[<h2 id="Python-Tools"><a href="#Python-Tools" class="headerlink" title="Python Tools"></a>Python Tools</h2><h3 id="itertools-Package"><a href="#itertools-Package" class="headerlink" title="itertools Package"></a><code>itertools</code> Package</h3><h4 id="itertools-islice-Function"><a href="#itertools-islice-Function" class="headerlink" title="itertools.islice() Function"></a><code>itertools.islice()</code> Function</h4><h4 id="itertools-zip-longest-Function"><a href="#itertools-zip-longest-Function" class="headerlink" title="itertools.zip_longest() Function"></a><code>itertools.zip_longest()</code> Function</h4><p><a href="https://www.geeksforgeeks.org/python-itertools-zip_longest/" target="_blank" rel="noopener">Python – Itertools.zip_longest()</a></p><h5 id="Leetcode-example"><a href="#Leetcode-example" class="headerlink" title="Leetcode example"></a>Leetcode example</h5><p><a href="https://leetcode.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">872. Leaf-Similar Trees</a></p><h4 id="itertools-permutations-Function"><a href="#itertools-permutations-Function" class="headerlink" title="itertools.permutations() Function"></a><code>itertools.permutations()</code> Function</h4><p><a href="https://www.geeksforgeeks.org/python-itertools-permutations/#" target="_blank" rel="noopener">Python – Itertools.Permutations()</a></p><h3 id="collections-Package"><a href="#collections-Package" class="headerlink" title="collections Package"></a><code>collections</code> Package</h3><h4 id="discard-Function-of-Set"><a href="#discard-Function-of-Set" class="headerlink" title="discard() Function of Set"></a><code>discard()</code> Function of Set</h4><h3 id="functools-Package"><a href="#functools-Package" class="headerlink" title="functools Package"></a><code>functools</code> Package</h3><h4 id="reduce-Function"><a href="#reduce-Function" class="headerlink" title="reduce() Function"></a><code>reduce()</code> Function</h4><p>Python’s reduce() implements a mathematical technique commonly known as folding or reduction. You’re doing a fold or reduction when you reduce a list of items to a single cumulative value. Python’s reduce() operates on any iterable—not just lists—and performs the following steps:</p><ul><li><p>Apply a function (or callable) to the first two items in an iterable and generate a partial result.</p></li><li><p>Use that partial result, together with the third item in the iterable, to generate another partial result.</p></li><li><p>Repeat the process until the iterable is exhausted and then return a single cumulative value.</p></li></ul><h3 id="random-Package"><a href="#random-Package" class="headerlink" title="random Package"></a><code>random</code> Package</h3><p>To generate random number in Python, <code>randint()</code> function is used.</p><blockquote><p>Return random integer in range [a, b], including both end points.</p></blockquote><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><h4 id="divmod-Function"><a href="#divmod-Function" class="headerlink" title="divmod() Function"></a><code>divmod()</code> Function</h4><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="Trim-Whitspace-from-String"><a href="#Trim-Whitspace-from-String" class="headerlink" title="Trim Whitspace from String"></a>Trim Whitspace from String</h4><p>Whitespace includes all Unicode whitespace characters, such as spaces, tabs (<code>\t</code>), carriage returns (<code>\r</code>), and newlines (<code>\n</code>). The Python <code>str()</code> class has the following methods that you can use to trim whitespace from a string:</p><ul><li><p><code>strip([chars])</code>: Trims characters from both ends of a string. When <code>chars</code> is omitted or None, returns a new string with all leading and trailing whitespace removed.</p></li><li><p><code>rstrip([chars])</code>: Trims characters from the right side of a string. When <code>chars</code> is omitted or None, returns a new string with all trailing whitespace removed.</p></li><li><p><code>lstrip([chars])</code>: Trims characters from the left side of a string. When <code>chars</code> is omitted or None, returns a new string with all leading whitespace removed.</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap</title>
      <link href="/p/488345055.html"/>
      <url>/p/488345055.html</url>
      
        <content type="html"><![CDATA[<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><p><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream</a></p><p><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">621. Task Scheduler</a></p><p><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">703. Kth Largest Element in a Stream</a></p><p><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. K Closest Points to Origin</a></p><p><a href="https://leetcode.com/problems/last-stone-weight/" target="_blank" rel="noopener">1046. Last Stone Weight</a></p><p><a href="https://leetcode.com/problems/minimum-interval-to-include-each-query/" target="_blank" rel="noopener">1851. Minimum Interval to Include Each Query</a></p><p><a href="https://leetcode.com/problems/smallest-number-in-infinite-set/" target="_blank" rel="noopener">2336. Smallest Number in Infinite Set</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/p/1624097203.html"/>
      <url>/p/1624097203.html</url>
      
        <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. First Missing Positive</a></p><p><a href="https://leetcode.com/problems/candy/" target="_blank" rel="noopener">135. Candy</a></p><p><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray</a></p><p><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">169. Majority Element</a></p><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence</a></p><p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. Minimum Number of Arrows to Burst Balloons</a></p><p><a href="https://leetcode.com/problems/132-pattern/" target="_blank" rel="noopener">456. 132 Pattern</a></p><p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">918. Maximum Sum Circular Subarray</a></p><p><a href="https://leetcode.com/problems/restore-the-array/" target="_blank" rel="noopener">1416. Restore The Array</a></p><p><a href="https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/" target="_blank" rel="noopener">1964. Find the Longest Valid Obstacle Course at Each Position</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree</title>
      <link href="/p/3772930202.html"/>
      <url>/p/3772930202.html</url>
      
        <content type="html"><![CDATA[<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><h3 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h3><h4 id="Preorder"><a href="#Preorder" class="headerlink" title="Preorder"></a>Preorder</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [root.val] + preorder(root.left) + preorder(root.right) <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="Inorder"><a href="#Inorder" class="headerlink" title="Inorder"></a>Inorder</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> inorder(root.left) + [root.val] + inorder(root.right) <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        ans.append(node.val)</span><br><span class="line">        root = node.right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="Postorder"><a href="#Postorder" class="headerlink" title="Postorder"></a>Postorder</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> postorder(root.left) + postorder(root.right) + [root.val] <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = [(root, <span class="literal">False</span>)]</span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, is_visited = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> is_visited:</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append((node, <span class="literal">True</span>))</span><br><span class="line">                stack.append((node.right, <span class="literal">False</span>))</span><br><span class="line">                stack.append((node.left, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum</a></p><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List</a></p><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph</title>
      <link href="/p/3364104920.html"/>
      <url>/p/3364104920.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">743. Network Delay Time</a></p><p><a href="https://leetcode.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">778. Swim in Rising Water</a></p><p><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops</a></p><p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener">802. Find Eventual Safe States</a></p><p><a href="https://leetcode.com/problems/design-graph-with-shortest-path-calculator/" target="_blank" rel="noopener">2642. Design Graph With Shortest Path Calculator</a></p><p><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/" target="_blank" rel="noopener">1584. Min Cost to Connect All Points</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/p/3198667018.html"/>
      <url>/p/3198667018.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="noopener">115. Distinct Subsequences</a></p><p><a href="https://leetcode.com/problems/coin-change-ii/" target="_blank" rel="noopener">518. Coin Change II</a></p><p><a href="https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/" target="_blank" rel="noopener">2218. Maximum Value of K Coins From Piles</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cycle Sort</title>
      <link href="/p/2447315839.html"/>
      <url>/p/2447315839.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. Find the Duplicate Number</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List</title>
      <link href="/p/3448994453.html"/>
      <url>/p/3448994453.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists</a></p><h3 id="Merge-Two-Lists"><a href="#Merge-Two-Lists" class="headerlink" title="Merge Two Lists"></a>Merge Two Lists</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span><span class="params">(list1: Optional[ListNode], list2: Optional[ListNode])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    head = list1</span><br><span class="line">    <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">        tmp = list1.next</span><br><span class="line">        list1.next = list2</span><br><span class="line">        list1 = list2</span><br><span class="line">        list2 = tmp</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="Add-operation"><a href="#Add-operation" class="headerlink" title="Add operation"></a>Add operation</h3><p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers</a></p><p>divmod() method</p><h3 id="Linked-list-cycle"><a href="#Linked-list-cycle" class="headerlink" title="Linked list cycle"></a>Linked list cycle</h3><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. Linked List Cycle</a></p><p>Floyd’s Cycle Finding Algorithm</p><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. Linked List Cycle II</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/p/4222665165.html"/>
      <url>/p/4222665165.html</url>
      
        <content type="html"><![CDATA[<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array</a></p><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[r]:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">162. Find Peak Element</a></p><p>bisect_left: 第一个大于等于</p><p>bisect_right: 第一个大于</p><p><a href="https://leetcode.com/problems/time-based-key-value-store/" target="_blank" rel="noopener">981. Time Based Key-Value Store</a></p><p><a href="https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/" target="_blank" rel="noopener">1751. Maximum Number of Events That Can Be Attended II</a></p><p><a href="https://leetcode.com/problems/maximum-running-time-of-n-computers/" target="_blank" rel="noopener">2141. Maximum Running Time of N Computers</a></p><p><a href="https://leetcode.com/problems/count-zero-request-servers/" target="_blank" rel="noopener">2747. Count Zero Request Servers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Round Number</title>
      <link href="/p/1469733108.html"/>
      <url>/p/1469733108.html</url>
      
        <content type="html"><![CDATA[<h2 id="Round-up-a-number-to-the-nearest-whole-number"><a href="#Round-up-a-number-to-the-nearest-whole-number" class="headerlink" title="Round up a number to the nearest whole number"></a>Round up a number to the nearest whole number</h2><ol><li><code>math.ceil()</code> method</li><li>math.ceil(p / m) equals to (p + m - 1) // 2</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monotonic Deque</title>
      <link href="/p/2255764225.html"/>
      <url>/p/2255764225.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. Sliding Window Maximum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Pointers</title>
      <link href="/p/1858691252.html"/>
      <url>/p/1858691252.html</url>
      
        <content type="html"><![CDATA[<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">424. Longest Repeating Character Replacement</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Sort</title>
      <link href="/p/741932282.html"/>
      <url>/p/741932282.html</url>
      
        <content type="html"><![CDATA[<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">        self._build_heap(arr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sort: O(nlogn)</span></span><br><span class="line">        length = len(arr)</span><br><span class="line">        <span class="keyword">for</span> end_index <span class="keyword">in</span> range(length - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            arr[<span class="number">0</span>], arr[end_index] = arr[end_index], arr[<span class="number">0</span>]</span><br><span class="line">            self._heapify(arr, <span class="number">0</span>, end_index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build heap: O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_build_heap</span><span class="params">(self, arr: List[int])</span>:</span></span><br><span class="line">        length = len(arr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range((length - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._heapify(arr, i, length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_heapify</span><span class="params">(self, arr: List[int], start_index: int, end_index: int)</span>:</span></span><br><span class="line">        cur, left, right = start_index, (start_index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, (start_index &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= end_index:</span><br><span class="line">            max_child_idx = right <span class="keyword">if</span> right &lt;= end_index <span class="keyword">and</span> arr[left] &lt; arr[right] <span class="keyword">else</span> left</span><br><span class="line">            <span class="keyword">if</span> arr[max_child_idx] &lt;= arr[cur]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            arr[cur], arr[max_child_idx] = arr[max_child_idx], arr[cur]</span><br><span class="line">            cur, left, right = max_child_idx, (max_child_idx &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, (max_child_idx &lt;&lt; <span class="number">1</span>) + <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="/p/3700626627.html"/>
      <url>/p/3700626627.html</url>
      
        <content type="html"><![CDATA[<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><a id="more"></a><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">332. Reconstruct Itinerary</a></p><p><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener">1319. Number of Operations to Make Network Connected</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disjoint Set</title>
      <link href="/p/528044520.html"/>
      <url>/p/528044520.html</url>
      
        <content type="html"><![CDATA[<h2 id="Disjoint-set-implementation-in-Python"><a href="#Disjoint-set-implementation-in-Python" class="headerlink" title="Disjoint set implementation in Python"></a>Disjoint set implementation in Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        root_i = self.find(i)</span><br><span class="line">        root_j = self.find(j)</span><br><span class="line">        self.parent[root_i] = root_j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] == i:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.parent = list(range(n))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node != self.parent[node]:</span><br><span class="line">            self.parent[node] = self.find(self.parent[node])</span><br><span class="line">        <span class="keyword">return</span> self.parent[node]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, node1, node2)</span>:</span></span><br><span class="line">        root1 = self.find(node1)</span><br><span class="line">        root2 = self.find(node2)</span><br><span class="line">        <span class="keyword">if</span> root1 == root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.parent[root1] = root2</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><p><a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener">684. Redundant Connection</a></p><p><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener">1319. Number of Operations to Make Network Connected</a></p><p><a href="https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/" target="_blank" rel="noopener">1697. Checking Existence of Edge Length</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Problems </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 工匠</title>
      <link href="/p/3401759717.html"/>
      <url>/p/3401759717.html</url>
      
        <content type="html"><![CDATA[<h2 id="第-1-章-变量与注释"><a href="#第-1-章-变量与注释" class="headerlink" title="第 1 章 变量与注释"></a>第 1 章 变量与注释</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="变量常见用法"><a href="#变量常见用法" class="headerlink" title="变量常见用法"></a>变量常见用法</h4><p>你可以在一行语句里同时操作多个变量，比如调换两个变量所指向的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>author, reader = <span class="string">'piglei'</span>, <span class="string">'raymond'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>author, reader = reader, author</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>author</span><br><span class="line"><span class="string">'raymond'</span></span><br></pre></td></tr></table></figure><h5 id="变量解包"><a href="#变量解包" class="headerlink" title="变量解包"></a>变量解包</h5><p>只要用星号表达式（*variables）作为变量名，它便会贪婪地捕获多个值对象，并将捕获到的内容作为列表赋值给 variables。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="string">'piglei'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>, <span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username, *fruits, score = data</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>username</span><br><span class="line"><span class="string">'piglei'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>score</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><h5 id="单下划线变量名"><a href="#单下划线变量名" class="headerlink" title="单下划线变量名 _"></a>单下划线变量名 _</h5><p>它作为一个无意义的占位符出现在赋值语句中。而在 Python 交互式命令行（直接执行 python 命令进入的交互环境）里，_ 变量还有一层特殊含义——默认保存我们输入的上个表达式的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'foo'</span>.upper()</span><br><span class="line"><span class="string">'FOO'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(_)</span><br><span class="line">FOO</span><br></pre></td></tr></table></figure><h4 id="给变量注明类型"><a href="#给变量注明类型" class="headerlink" title="给变量注明类型"></a>给变量注明类型</h4><p>Python 官方推荐的 Sphinx 格式文档后的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_invalid</span><span class="params">(items)</span>:</span></span><br><span class="line">    <span class="string">""" 剔除 items 里面无效的元素</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    : param items: 待剔除对象</span></span><br><span class="line"><span class="string">    : type items: 包含整数的列表，[int, ...]</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>相比编写 Sphinx 格式文件，我其实更推荐使用类型注释，因为它是 Python 的内置功能。比如 func(value: str) 表示函数的 value 参数为字符串类型。</p><p>下面是给 remove_invalid() 函数添加类型注释后的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_invalid</span><span class="params">(items: List[int])</span>:</span></span><br><span class="line">    <span class="string">""" 剔除 items 里面无效的元素</span></span><br><span class="line"><span class="string">    ... ...</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>注：“类型注释”只是一种有关类型的注释，不提供任何校验功能。要校验类型正确性，需要使用其他静态类型检查工具（如 mypy 等）。</p><a id="more"></a><h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4><h5 id="遵循-PEP-8-原则"><a href="#遵循-PEP-8-原则" class="headerlink" title="遵循 PEP 8 原则"></a>遵循 PEP 8 原则</h5><h5 id="描述性要强"><a href="#描述性要强" class="headerlink" title="描述性要强"></a>描述性要强</h5><h5 id="要尽量短"><a href="#要尽量短" class="headerlink" title="要尽量短"></a>要尽量短</h5><h5 id="要匹配类型"><a href="#要匹配类型" class="headerlink" title="要匹配类型"></a>要匹配类型</h5><h5 id="超短命名"><a href="#超短命名" class="headerlink" title="超短命名"></a>超短命名</h5><h4 id="注释基础知识"><a href="#注释基础知识" class="headerlink" title="注释基础知识"></a>注释基础知识</h4><p>除使用 # 的注释外，另一种注释则是我们前面看到过的函数（类）文档（docstring），这些文档也称接口注释（interface comment）。</p><h5 id="用注释屏蔽代码（×）"><a href="#用注释屏蔽代码（×）" class="headerlink" title="用注释屏蔽代码（×）"></a>用注释屏蔽代码（×）</h5><h5 id="用注释复述代码（×）"><a href="#用注释复述代码（×）" class="headerlink" title="用注释复述代码（×）"></a>用注释复述代码（×）</h5><h5 id="弄错接口注释的受众（×）"><a href="#弄错接口注释的受众（×）" class="headerlink" title="弄错接口注释的受众（×）"></a>弄错接口注释的受众（×）</h5><h3 id="案例故事"><a href="#案例故事" class="headerlink" title="案例故事"></a>案例故事</h3><p>冒泡排序算法</p><h3 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="保持变量的一致性"><a href="#保持变量的一致性" class="headerlink" title="保持变量的一致性"></a>保持变量的一致性</h4><h4 id="变量定义尽量靠近使用"><a href="#变量定义尽量靠近使用" class="headerlink" title="变量定义尽量靠近使用"></a>变量定义尽量靠近使用</h4><h4 id="定义临时变量提升可读性"><a href="#定义临时变量提升可读性" class="headerlink" title="定义临时变量提升可读性"></a>定义临时变量提升可读性</h4><p>注：直接翻译业务逻辑的代码，大多不是好代码。优秀的程序设计师需要在理解原需求的基础上，恰到好处地抽象，只有这样才能同时满足可读性和扩展性方面的需求。</p><h4 id="同一作用域内不要有太多变量"><a href="#同一作用域内不要有太多变量" class="headerlink" title="同一作用域内不要有太多变量"></a>同一作用域内不要有太多变量</h4><h4 id="能不定义变量就别定义"><a href="#能不定义变量就别定义" class="headerlink" title="能不定义变量就别定义"></a>能不定义变量就别定义</h4><h4 id="不要使用-locals"><a href="#不要使用-locals" class="headerlink" title="不要使用 locals()"></a>不要使用 locals()</h4><p>locals() 是 Python 的一个内置函数，调用它会返回当前作用域中的所有局部变量。</p><h4 id="空行也是一种“注释”"><a href="#空行也是一种“注释”" class="headerlink" title="空行也是一种“注释”"></a>空行也是一种“注释”</h4><h4 id="先写注释，后写代码"><a href="#先写注释，后写代码" class="headerlink" title="先写注释，后写代码"></a>先写注释，后写代码</h4><p>在写出一句有说服力的接口注释前，别写任何函数代码。</p><h2 id="第-2-章-数值与字符串"><a href="#第-2-章-数值与字符串" class="headerlink" title="第 2 章 数值与字符串"></a>第 2 章 数值与字符串</h2><p>在 Python 里使用整型，你不需要了解“有符号”“无符号”“32位”“64位”这些令人头疼的概念。不论多大的数字都能直接用，不必担心任何溢出问题。</p><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="数值基础"><a href="#数值基础" class="headerlink" title="数值基础"></a>数值基础</h4><p>在 Python 中，一共存在三种内置数值类型：整型（int）、浮点型（float）和复数类型（complex）。创建这三类数值很简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个整型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>score = <span class="number">100</span></span><br><span class="line"><span class="comment"># 定义一个浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = <span class="number">37.2</span></span><br><span class="line"><span class="comment"># 定义一个复数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>com = <span class="number">1</span> + <span class="number">2j</span></span><br></pre></td></tr></table></figure><p>在定义数值字面量时，如果数字特别长，可以通过插入 _ 分隔符来让它变得更易读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以“千”为单位分割数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">1</span>_000_000</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> + <span class="number">10</span></span><br><span class="line"><span class="number">1000010</span></span><br></pre></td></tr></table></figure><p>浮点数存在精度问题。Python 使用的是“双精度”。假如你的程序需要精度的浮点数计算，请考虑使用 decimal.Decimal 对象来替代普通浮点数，它在做四则运算时不会损失任何精度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="comment"># 注意：这里的‘0.1’和‘0.2’必须是字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Deciaml(<span class="string">'0.1'</span>) + Decimal(<span class="string">'0.2'</span>)</span><br><span class="line">Decimal(<span class="string">'0.3'</span>)</span><br></pre></td></tr></table></figure><p>在使用Decimal的过程中，大家需要注意：必须使用字符串来表示数字。</p><p>如果你想了解更多浮点数相关的内容，可查看 Python 官方文档中的“1.5 Floating Point Arithmetic: Issue and Limitations”，其中的介绍非常详细。</p><h4 id="布尔值其实也是数字"><a href="#布尔值其实也是数字" class="headerlink" title="布尔值其实也是数字"></a>布尔值其实也是数字</h4><p>布尔值的这个特点，常用来简化统计总数操作。</p><p>假设有一个包含整数的列表，我需要计算列表里一共有多少个偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = sum(i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure><h4 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h4><h5 id="把字符串当序列来操作"><a href="#把字符串当序列来操作" class="headerlink" title="把字符串当序列来操作"></a>把字符串当序列来操作</h5><p>假如你想反转一个字符串，可以使用切片操作或者 reversed 内置方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-1</span>]</span><br><span class="line"><span class="string">'!dlrow ,hlleH'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join(reversed(s))</span><br><span class="line"><span class="string">'!dlrow ,hlleH'</span></span><br></pre></td></tr></table></figure><p>切片最后一个字符使用 -1，表示从后往前反序；<br>reversed 会返回一个可迭代对象，通过字符串的 .join 方法可以将它转换为字符串</p><h5 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">username, score = <span class="string">'piglei'</span>, <span class="number">100</span></span><br><span class="line"><span class="comment"># 1. C 语言风格格式化</span></span><br><span class="line">print(<span class="string">'Welcome %s, your score is %d'</span> % (username, score))</span><br><span class="line"><span class="comment"># 2. str.format</span></span><br><span class="line">print(<span class="string">'Welcome &#123;&#125;, your score is &#123;:d&#125;'</span>.format(username, score))</span><br><span class="line"><span class="comment"># 3. f-string，最简短直观</span></span><br><span class="line">print(<span class="string">f'Welcome <span class="subst">&#123;username&#125;</span>, your score is <span class="subst">&#123;score:d&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># Welcome piglei, your score is 100</span></span><br></pre></td></tr></table></figure><p>str.format 与 f-string 共享了同一种复杂的“字符串格式化微语言”。通过这种微语言，我们可以方便地对字符串进行二次加工，然后输出。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 username 靠右对齐，左侧补空格到一共 20 个字符</span></span><br><span class="line"><span class="comment"># 以下两种方式将输出同样的内容</span></span><br><span class="line">print(<span class="string">'&#123;:&gt;20&#125;'</span>.format(username))</span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;username:&gt;<span class="number">20</span>&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment">#              piglei</span></span><br></pre></td></tr></table></figure><p>日常编码中，推荐优先使用 f-string，搭配 str.format 作为补充，想必能满足大家绝大多数的字符串格式化需求。</p><p>注：查看 Python 官方文档中的“Format Specification Mini-Language”一节，了解字符串格式化微语言更多的相关内容。</p><h5 id="拼接多个字符串"><a href="#拼接多个字符串" class="headerlink" title="拼接多个字符串"></a>拼接多个字符串</h5><p>假如要拼接二多个字符串，比较常见的 Python 式做法是：首先创建一个空列表，然后把需要拼接的字符串都放进列表，最后调用 str.join 来获得大字符串。</p><p>在拼接字符串时，+= 和 join同样好用。</p><h4 id="不常用但特别好用的字符串方法"><a href="#不常用但特别好用的字符串方法" class="headerlink" title="不常用但特别好用的字符串方法"></a>不常用但特别好用的字符串方法</h4><p>.join(), .split(), .startswith(), <strong>.isdigit()</strong>, <strong>.partition(sep)</strong>, <strong>.translate(table)</strong></p><h4 id="字符串与字节串"><a href="#字符串与字节串" class="headerlink" title="字符串与字节串"></a>字符串与字节串</h4><ol><li>字符串：我们常挂在嘴边的“普通字符串”，有时也被称为<strong>文本（text）</strong>，是给人看的，对应 Python 中的字符串（str）类型。str 使用 Unicode 标准，可通过 .encode() 方法编码为字节串。</li><li>字节串：有时也称“二进制字符串”（binary string），是给计算机看的，对应 Python 中的字节串（bytes）类型。bytes 一定包含某种真正的字符串编码格式（默认为 UTF-8），可通过 .decode() 解码为字符串。</li></ol><p>要创建一个字节串字面量，可以在字符串前加一个字母 b 作为前缀。bytes 和 str 是两种数据类型，即便有时看上去“一样”，但作比较时永不相等。</p><p>必须操作处理字节串的场景，一般来说只有两种：</p><ol><li>程序从文件或其他外部存储读取字节串内容，将其解码为字符串，然后再在内部使用；</li><li>程序完成处理，要把字符串写入文件或其他外部存储，将其编码为字节串，然后继续执行其他操作。</li></ol><h3 id="案例故事-1"><a href="#案例故事-1" class="headerlink" title="案例故事"></a>案例故事</h3><h4 id="代码里的“密码”"><a href="#代码里的“密码”" class="headerlink" title="代码里的“密码”"></a>代码里的“密码”</h4><h5 id="“密码”的含义"><a href="#“密码”的含义" class="headerlink" title="“密码”的含义"></a>“密码”的含义</h5><h5 id="改善代码的可读性"><a href="#改善代码的可读性" class="headerlink" title="改善代码的可读性"></a>改善代码的可读性</h5><p>除了定义常量以外，还可以使用枚举类型（enum.Enum）。在定义枚举类型时，如果同时继承一些基础类型，比如 int，str，枚举类型就能同时充当该基础类型使用。</p><h4 id="别轻易成为-SQL-语句“大师”"><a href="#别轻易成为-SQL-语句“大师”" class="headerlink" title="别轻易成为 SQL 语句“大师”"></a>别轻易成为 SQL 语句“大师”</h4><h5 id="使用-SQLAlchemy-模块改写代码"><a href="#使用-SQLAlchemy-模块改写代码" class="headerlink" title="使用 SQLAlchemy 模块改写代码"></a>使用 SQLAlchemy 模块改写代码</h5><h5 id="使用-Jinja2-模块处理字符串"><a href="#使用-Jinja2-模块处理字符串" class="headerlink" title="使用 Jinja2 模块处理字符串"></a>使用 Jinja2 模块处理字符串</h5><p>当你的代码里出现复杂的裸字符串处理逻辑时，请试着问自己一个问题：“目标/源字符串是<strong>结构化</strong>的且遵循某种格式吗？”如果答案是肯定的，那么请先寻找是否有对应的开源专属模块，比如处理 SQL 语句的 SQLAlchemy、处理 XML 的 lxml 模块等。</p><p>如果你要拼接<strong>非结构化</strong>的字符串，也请先考虑使用 Jinja2 等模块引擎，而不是手动拼接。</p><h3 id="编程建议-1"><a href="#编程建议-1" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="不必预计算字面量表达式"><a href="#不必预计算字面量表达式" class="headerlink" title="不必预计算字面量表达式"></a>不必预计算字面量表达式</h4><p><strong>使用 dis 模块反编译字节码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 导入 dis 模块，使用它打印 add() 函数的字节码，也就是解释器如何理解 add() 函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> dis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(add)</span><br><span class="line">  <span class="number">2</span>         <span class="number">0</span> LOAD_FAST        <span class="number">0</span> (x)</span><br><span class="line">            <span class="number">2</span> LOAD_FAST        <span class="number">1</span> (y)</span><br><span class="line">            <span class="number">4</span> BINARY_ADD</span><br><span class="line">            <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><h4 id="使用特殊数字：“无穷大”"><a href="#使用特殊数字：“无穷大”" class="headerlink" title="使用特殊数字：“无穷大”"></a>使用特殊数字：“无穷大”</h4><p>float(“inf”), float(“-inf”)</p><h4 id="改善超长字符串的可读性"><a href="#改善超长字符串的可读性" class="headerlink" title="改善超长字符串的可读性"></a>改善超长字符串的可读性</h4><p>除了用斜杠 \ 和加号 + 将长字符串拆分为几段，还有一种更简单的方法，那就是拿括号将长字符串包起来，之后就可以随意折行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = (<span class="string">"This is the first line of a long string, "</span></span><br><span class="line">     <span class="string">"this is the second line"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果字符串出现在函数参数等位置，可以省略一层括号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    logger.info(<span class="string">"This is the first line of a long string, "</span></span><br><span class="line">                <span class="string">"this is the second line"</span>)</span><br></pre></td></tr></table></figure><p><strong>多级缩进里出现多行字符串</strong></p><p>可以使用textwrap标准库。</p><h4 id="别忘了以-r-开头的字符串内置方法"><a href="#别忘了以-r-开头的字符串内置方法" class="headerlink" title="别忘了以 r 开头的字符串内置方法"></a>别忘了以 r 开头的字符串内置方法</h4><p>例 .rsplit()</p><h4 id="不要害怕字符串拼接"><a href="#不要害怕字符串拼接" class="headerlink" title="不要害怕字符串拼接"></a>不要害怕字符串拼接</h4><p>使用 timeit 模块可以对 Python 代码方便地进行性能测试。</p><h2 id="第-3-章-容器类型"><a href="#第-3-章-容器类型" class="headerlink" title="第 3 章 容器类型"></a>第 3 章 容器类型</h2><p><strong>列表（list）</strong>是一种非常经典的容器类型，通常用来存放多个同类对象，比如从 1 到 10 的所有整数。</p><p><strong>元组（tuple）</strong>和列表非常类似，但跟列表不同，它不能被修改。这意味着元组完成初始化后就没法再改动了。</p><p><strong>字典（dict）</strong>：每个类实例的所有属性，都存放在一个名为 __dict__ 的字典里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">'bar'</span>)</span><br><span class="line">print(foo.__dict__, type(foo.__dict__))</span><br></pre></td></tr></table></figure><p>执行后输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'value'</span>: <span class="string">'bar'</span>&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></table></figure><p><strong>集合（set）</strong></p><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="列表常用操作"><a href="#列表常用操作" class="headerlink" title="列表常用操作"></a>列表常用操作</h4><p>常用的列表创建方式有两种：字面量语法与 list() 内置函数。</p><p>内置函数 list(iterable) 可以把<strong>任何</strong>一个<strong>可迭代对象</strong>转换为列表，比如字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(<span class="string">'foo'</span>)</span><br><span class="line">[<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://kelepython.readthedocs.io/zh/latest/c01/c01_11.html" target="_blank" rel="noopener">摘自网络</a><br>可迭代对象：简单来理解，任何你可以循环遍历的对象都是可迭代对象。<br>可使用<code>isinstance() 函数</code>来判断对象是否是可迭代对象：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="comment"># 字符串是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"kele"</span>, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 列表是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="string">"kele"</span>], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 字典是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;<span class="string">"name"</span>: <span class="string">"kele"</span>&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 集合是可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 数字是不可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">2</span>, Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>对比可迭代对象与不可迭代对象的所有属性与方法，我们发现：可迭代对象都构建了 <code>__iter__</code> 方法，而不可迭代对象没有构建，因此我们也可通过此特点来判断某一对象是不是可迭代对象。</p><p><strong>迭代器（Iterator）</strong>是同时实现 __iter__() 与 __next__() 方法的对象。它可通过 __next__() 方法或者一般的 for 循环进行遍历，能够记录每次遍历的位置，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束，迭代器只能往前不能后退，终止迭代则会抛出 StopIteration 异常。</p></blockquote><p>对于已有列表，我们可以通过索引访问它的成员。要删除列表中的某些内容，可以直接使用 del 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过索引获取内容，如果索引越界，会抛出 IndexError 异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">2</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 使用切片获取一段内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers[<span class="number">1</span>:]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列表中的一段内容</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> numbers[<span class="number">1</span>:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="在遍历列表时获取下标"><a href="#在遍历列表时获取下标" class="headerlink" title="在遍历列表时获取下标"></a>在遍历列表时获取下标</h5><p><strong>enumerate()</strong>: 适用于任何“可迭代对象”，因此它不光可以用于列表，还可以用于元组、字典、字符串等其他对象。</p><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用一个表达式完成4件事情</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1. 遍历旧列表：for n in numbers</span></span><br><span class="line"><span class="comment"># 2. 对成员进行条件过滤：if n % 2 == 0</span></span><br><span class="line"><span class="comment"># 3. 修改成员：n * 100</span></span><br><span class="line"><span class="comment"># 4. 组装新的结果列表</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">result = [n * <span class="number">100</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="理解列表的可变性"><a href="#理解列表的可变性" class="headerlink" title="理解列表的可变性"></a>理解列表的可变性</h4><p>Python 里的内置数据类型，大致上可分为可变与不可变两种。</p><ul><li>可变（mutable）：列表、字典、集合。</li><li>不可变（immutable）：整数、浮点数、字符串、字节串、元组。</li></ul><p>Python 在进行函数调用传参时，采用的既不是值传递，也不是引用传递，而是传递了“变量所指对象的引用”（pass-by-object-reference）。</p><p>换个角度说，当你调用 func(orig_obj) 后，Python 只是新建了一个函数内部变量 in_func_obj，然后让它和外部变量 orig_obj 指向同一个对象，相当于做了一次变量赋值。</p><p>Python 的函数调用不能简单归类为“值传递”或者“引用传递”，一切行为取决于对象的可变性。</p><h4 id="常用元组操作"><a href="#常用元组操作" class="headerlink" title="常用元组操作"></a>常用元组操作</h4><p>元组也有两种常用的定义方式——字面量表达式和 tuple() 内置函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字面量语法定义元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 真相：“括号”其实不是定义元组的关键标志——直接删除括号</span></span><br><span class="line"><span class="comment"># 同样也能定义元组，“逗号”才是让解释器判定为元组的关键</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tuple(iterable) 内置函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = tuple(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>)</span><br></pre></td></tr></table></figure><p>由于元组不可变，所以它没有列表那一堆内置方法，比如 .append()、.extend() 等方法。</p><h5 id="返回多个结果，其实就是返回元组"><a href="#返回多个结果，其实就是返回元组" class="headerlink" title="返回多个结果，其实就是返回元组"></a>返回多个结果，其实就是返回元组</h5><p>将函数返回值一次赋值给多个变量时，其实就是对元组做了一次解包操作。</p><h5 id="没有“元组推导式”"><a href="#没有“元组推导式”" class="headerlink" title="没有“元组推导式”"></a>没有“元组推导式”</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = (n * <span class="number">100</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10e94e2e0</span>&gt;</span><br></pre></td></tr></table></figure><p>很遗憾，上面的表达式并没生成元组，而是返回了一个<strong>生成器（generator）</strong>对象。因此它是生成器推导式，而非元组推导式。</p><p>不过，生成器仍然是一种可迭代类型，所以我们还是可以对它调用 tuple() 函数，获得元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = tuple((n * <span class="number">100</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">(<span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>, <span class="number">600</span>, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><h5 id="存放结构化数据"><a href="#存放结构化数据" class="headerlink" title="存放结构化数据"></a>存放结构化数据</h5><p>元组经常用来存放结构化数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info = (<span class="string">'piglei'</span>, <span class="string">'MALE'</span>, <span class="number">30</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>user_info[<span class="number">2</span>]</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>正因为元组有这个特点，所以 Python 为我们提供了一个特殊的元组类型：具名元组。</p><h4 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Rectangle = namedtuple(<span class="string">'Rectangle'</span>, [<span class="string">'width'</span>, <span class="string">'height'</span>])</span><br></pre></td></tr></table></figure><p>使用情况如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect = Rectangle(<span class="number">100</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect = Rectangle(width = <span class="number">100</span>, height = <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rect[<span class="number">0</span>])</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rect.width)</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect.width += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure><p>在 Python 3.6 版本以后，除了使用 namedtuple() 函数以外，你还可以用 typing.NamedTuple 和<strong>类型注解语法</strong>来定义具名元组类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(NamedTuple)</span>:</span></span><br><span class="line">    width: int</span><br><span class="line">    height: int</span><br><span class="line"></span><br><span class="line">rect = Rectangle(<span class="number">100</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h4 id="字典常用操作"><a href="#字典常用操作" class="headerlink" title="字典常用操作"></a>字典常用操作</h4><h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历获取字典所有的 key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> movie:</span><br><span class="line">        print(key, movie[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次获取字典的所有 key: value 键值对：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> movie.items():</span><br><span class="line">        print(key, value)</span><br></pre></td></tr></table></figure><h5 id="访问不存在的字典键"><a href="#访问不存在的字典键" class="headerlink" title="访问不存在的字典键"></a>访问不存在的字典键</h5><p>如果只是“提供默认值的读取操作”，其实可以直接使用字典的 .get() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：此时 movie 里没有 rating 字段</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>movie.get(<span class="string">'rating'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="使用-setdefault-取值并修改"><a href="#使用-setdefault-取值并修改" class="headerlink" title="使用 setdefault 取值并修改"></a>使用 setdefault 取值并修改</h5><p>视条件不同，调用 dict.setdefault(key, default) 会产生两种结果：当 key 不存在时，该方法会把 default 值写入字典的 key 位置，并返回该值；假如 key 已经存在，该方法就会直接返回它在字典中的对应值。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'title'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">'items'</span>, []).append(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'title'</span>: <span class="string">'foobar'</span>, <span class="string">'items'</span>: [<span class="string">'foo'</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.setdefault(<span class="string">'items'</span>, []).append(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'title'</span>: <span class="string">'foobar'</span>, <span class="string">'items'</span>: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-pop-方法删除不存在的键"><a href="#使用-pop-方法删除不存在的键" class="headerlink" title="使用 pop 方法删除不存在的键"></a>使用 pop 方法删除不存在的键</h5><p>如果我们想删除字典里的某个键，一般会使用 del d[key] 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">del</span> d[key]</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="comment"># 忽略 key 不存在的情况</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>但假设你只是单纯想删除某个键，并不关心它存在与否、删除是否成功，那么请使用 dict.pop(key, default) 方法就够了。</p><p>严格来说，pop 方法的主要用途并不是删除某个键，而是取出这个键对应的值。但我个人觉得，偶尔拿它来执行删除操作也无伤大雅。</p><h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'foo'</span>: <span class="number">3</span>, <span class="string">'bar'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;key: value * <span class="number">10</span> <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items() <span class="keyword">if</span> key == <span class="string">'foo'</span>&#125;</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="认识字典的有序性和无序性"><a href="#认识字典的有序性和无序性" class="headerlink" title="认识字典的有序性和无序性"></a>认识字典的有序性和无序性</h4><p>在 Python 3.6 之前，几乎所有开发者都遵循一条常识：“Python 的字典是无序的”。</p><p>一开始，字典变为有序只是作为 3.6 版本的“隐藏特性”存在。但到了 3.7 版本，它已经彻底成了语言规范的一部分。如今，当你使用字典时，当程序的运行环境是 Python 3.7 或更高版本，那你完全可以依赖字典类型的<strong>有序</strong>特性。</p><p>但如果你使用的版本没那么高，你也可以从 collections 模块里拿到一个有序字典对象 OrderedDict：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = OrderedDict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'FIRST_KEY'</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'SECOND_KEY'</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">        print(key)</span><br><span class="line">FIRST_KEY</span><br><span class="line">SECOND_KEY</span><br></pre></td></tr></table></figure><p>OrderedDict 最初出现的版本在 2009 年发布的 Python 3.1。</p><p>从功能上说，OrderedDict 与新版本的字典其实有一点细微区别。比如，在对比两个内容相同而顺序不同的字典对象时，解释器会返回 True 结果；但如果是 OrderDict 对象，则会返回 False。除此之外，OrderedDict 还有 .move_to_end() 等普通字典没有的一些方法。</p><h4 id="集合常用操作"><a href="#集合常用操作" class="headerlink" title="集合常用操作"></a>集合常用操作</h4><p>初始化一个集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = &#123;<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pineapple'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits</span><br><span class="line">&#123;<span class="string">'pineapple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化空集合只能使用 set()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>empty_set = set()</span><br></pre></td></tr></table></figure><p>集合也有自己的推导式语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;n <span class="keyword">for</span> n <span class="keyword">in</span> nums <span class="keyword">if</span> n &lt; <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="不可变的集合-frozenset"><a href="#不可变的集合-frozenset" class="headerlink" title="不可变的集合 frozenset"></a>不可变的集合 frozenset</h5><p>集合是一种可变类型，利用 .add() 方法可以向集合追加新成员。</p><p>假如你想要一个不可变的集合，可使用内置类型 frozenset，它和普通 set 非常像，只是少了所有的修改类方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_set = frozenset([<span class="string">'foo'</span>, <span class="string">'bar'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f_set.add(<span class="string">'apple'</span>)</span><br><span class="line">AttributeError: <span class="string">'frozenset'</span> object has no attribute <span class="string">'add'</span></span><br></pre></td></tr></table></figure><h5 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集：使用 &amp; 运算符 或 使用 intersection 方法完成同样的功能</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1 &amp; fruits_2</span><br><span class="line">&#123;<span class="string">'orange'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1.intersection(fruits_2)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集：使用 | 运算符 或 使用 union 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1 | fruits_2</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1.union(fruits_2)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集：使用 - 运算符 或 使用 difference 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1 - fruits_2</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits_1.difference(fruits_2)</span><br></pre></td></tr></table></figure><p>除了上面这三种运算，集合还有 symmetric_difference、issubset 等其他许多有用的操作。</p><h5 id="集合只能存放可哈希对象"><a href="#集合只能存放可哈希对象" class="headerlink" title="集合只能存放可哈希对象"></a>集合只能存放可哈希对象</h5><p>集合里只能存放“可哈希”（hashable）对象。</p><h4 id="了解对象的可哈希性"><a href="#了解对象的可哈希性" class="headerlink" title="了解对象的可哈希性"></a>了解对象的可哈希性</h4><p>在介绍字典类型时，我们说过字典底层使用了哈希表数据结构，其实集合也是一样。当我们把某个对象放进集合或者作为字典的键使用时，解释器都需要对该对象进行一次哈希运算，得到哈希值，然后再进行后面的操作。</p><p>这个计算哈希值的过程，是通过调用内置函数 <strong>hash(obj)</strong> 完成的。如果对象是可哈希的，hash 函数会返回一个整型结果，否则会报 TypeError 错误。</p><p>总结一下，某种类型是否可哈希遵循下面的规则：</p><ol><li>所有的不可变内置类型都是可哈希的，比如，str、int、tuple、frozenset 等；</li><li>所有的可变内置类型，都是不可哈希的，比如，dict、list 等；</li><li>对于不可变容器类型（tuple、frozenset），仅当它的所有成员都不可变时，它自身才是可哈希的；</li><li>用户定义的类型默认都是可哈希的。</li></ol><p>谨记，只有<strong>可哈希</strong>的对象，才能放进<strong>集合</strong>或作为<strong>字典的键</strong>使用。</p><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>copy 模块下的 copy() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums_copy = copy.copy(nums)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums[<span class="number">2</span>] = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums, nums_copy</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">30</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>对于那些支持推导式的类型，用推导式也可以产生一个浅拷贝对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'foo'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items()&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'foo'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d, d2</span><br><span class="line">(&#123;<span class="string">'foo'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'foo'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>使用各容器类型的内置构造函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = dict(d.items())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums_copy = list(nums)</span><br></pre></td></tr></table></figure><p>对于支持切片操作的类型——比如列表、元组，对其进行全切片也可以实现浅拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums_copy = nums[:]</span><br></pre></td></tr></table></figure><p>有些类型自身就提供了浅拷贝方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums.copy()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.copy()</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>可使用 copy.deepcopy() 函数来进行深拷贝操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items_deep = copy.deepcopy(items)</span><br></pre></td></tr></table></figure><h3 id="案例故事-2"><a href="#案例故事-2" class="headerlink" title="案例故事"></a>案例故事</h3><h4 id="分析网站访问日志"><a href="#分析网站访问日志" class="headerlink" title="分析网站访问日志"></a>分析网站访问日志</h4><h5 id="使用-defaultdict-类型"><a href="#使用-defaultdict-类型" class="headerlink" title="使用 defaultdict 类型"></a>使用 defaultdict 类型</h5><p>defaultdict(default_factory) 是一种特殊的字典类型。它在被初始化时，接收一个可调用对象 default_factory 作为参数。之后每次进行 d[key] 操作时，如果访问的 key 不存在时，defaultdict 对象会自动调用 default_factory() 并将结果作为值保存在对应的 key 里。</p><h5 id="使用-MutableMapping-创建自定义字典类型"><a href="#使用-MutableMapping-创建自定义字典类型" class="headerlink" title="使用 MutableMapping 创建自定义字典类型"></a>使用 MutableMapping 创建自定义字典类型</h5><p>编写了一个继承了 MutableMapping 的字典类 PerfLevelDict。但继承还不够，要让这个类变得像字典一样，还需要重写包括 __getitem__、__setitem__ 在内的 6 个魔法方法。</p><p>其中最重要的几点简单说明如下：</p><ol><li>在 __init__ 初始化方法里，使用 defaultdict(int) 对象来简化字典的空值初始化操作；</li><li>__getitem__ 方法定义了 d[key] 取值操作时的行为；</li><li>__setitem__ 方法定义了 d[key] = value 赋值操作时的行为；</li><li>PerfLevelDict 的 __getitem__/__setitem__ 方法和普通字典的最大不同，在于操作前调用了 compute_level()，将字典键转成了性能等级。</li></ol><h5 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h5><h3 id="编程建议-2"><a href="#编程建议-2" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="用按需返回替代容器"><a href="#用按需返回替代容器" class="headerlink" title="用按需返回替代容器"></a>用按需返回替代容器</h4><p>Python 2 中的 range() 会一次性返回所有数字。</p><p>但到了 Python 3，调用 range(10000000) 瞬间就会返回结果。因为它不再返回列表，而是返回一个类型为 range 的惰性计算对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = range(<span class="number">1000000</span>)</span><br><span class="line"><span class="comment"># r 是 range 对象，而非装满数字的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r</span><br><span class="line">range(<span class="number">0</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">range</span>'&gt;</span></span><br><span class="line"><span class="class"># 只有在迭代 <span class="title">range</span> 对象时，它才会不断生成新的数字</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">r</span>:</span></span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure><p>range() 的进化过程虽然简单，但它其实代表了一种重要的编程思维——<strong>按需生成，而不是一次性返回</strong>。</p><h5 id="生成器简介"><a href="#生成器简介" class="headerlink" title="生成器简介"></a>生成器简介</h5><p><strong>生成器（generator）</strong>是 Python 里的一种特殊的数据类型。顾名思义，它是一个不断给调用方“生成”内容的类型。定义一个生成器，需要用到<strong>生成器函数</strong>与 <strong>yield</strong> 关键字。</p><p>一个最简单的生成器如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_even</span><span class="params">(max_number)</span>:</span></span><br><span class="line">    <span class="string">""" 一个简单生成器，返回 0 到 max_number 之间的所有偶数 """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, max_number):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generate_even(<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>虽然都是返回结果，但 yield 和 return 的最大不同之处在于，return 的返回是一次性的，使用它会直接中断整个函数执行，而 yield 可以逐步给调用方生成结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = generate_even(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 调用 next() 可以逐步从生成器对象里拿到结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(i)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>因为生成器是可迭代对象，所以你可以使用 list() 等函数方便地把它转换为各种其他容器类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(generate_even(<span class="number">10</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><blockquote><p>yield 关键字：<a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="noopener">网络解释</a></p></blockquote><h5 id="用生成器替代列表"><a href="#用生成器替代列表" class="headerlink" title="用生成器替代列表"></a>用生成器替代列表</h5><p>一种常用模式：“初始化结果容器 -&gt; 处理 -&gt; 将结果存入容器 -&gt; 返回容器”。这个模式存在两个问题：</p><ul><li>如果需要处理的对象 items 过大，batch_process() 函数就会像 Python 2 里的 range() 函数一样，每次执行都会特别慢，存放结果的对象 results 也会占用大量内存。</li><li>如果<strong>函数调用方</strong>想在某个 processed_item 对象满足特定条件时中断，不再继续处理后面的对象，这种模式也做不到。</li></ul><p>为了解决这两个问题，我们可以用生成器函数来改写它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_process</span><span class="params">(items)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="comment"># processed_item = ...</span></span><br><span class="line">        <span class="keyword">yield</span> processed_item</span><br></pre></td></tr></table></figure><p>如果调用方需要在某些条件下中断处理，也完全可以做到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">for</span> processed_item <span class="keyword">in</span> batch_process(items):</span><br><span class="line">    <span class="keyword">if</span> processed_item.has_expired():</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="了解容器的底层实现"><a href="#了解容器的底层实现" class="headerlink" title="了解容器的底层实现"></a>了解容器的底层实现</h4><h5 id="避开列表的性能陷阱"><a href="#避开列表的性能陷阱" class="headerlink" title="避开列表的性能陷阱"></a>避开列表的性能陷阱</h5><p>Python 在实现列表时，底层使用了<strong>数组（array）</strong>数据结构。</p><p>如果你经常需要往列表头部插入数据，请考虑使用 collections.deque 类型来替代列表。因为 deque 底层使用了<strong>双端队列</strong>，无论从头部还是尾部追加成员，时间复杂度都是 O(1)。</p><h5 id="使用集合判断成员是否存在"><a href="#使用集合判断成员是否存在" class="headerlink" title="使用集合判断成员是否存在"></a>使用集合判断成员是否存在</h5><p>要判断某个容器是否包含特定成员，用集合比用列表更合适。集合底层使用了<strong>哈希表</strong>数据结构。要判断集合中是否存在某个对象 obj，Python 只需先用 hash(obj) 算出它的哈希值，然后直接去哈希表对应位置检查 obj 是否存在即可，根本不需要关心哈希表的其他部分，一步到位。</p><p>如果代码需要进行 in 判断，可以考虑把目标容器转换成集合类型，作为查找时的索引使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VALID_NAME = [<span class="string">'piglei'</span>, <span class="string">'raymond'</span>, <span class="string">'bojack'</span>, <span class="string">'caroline'</span>]</span><br><span class="line"></span><br><span class="line">VALID_NAMES_SET = set(VALID_NAME)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_name</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> VALID_NAMES_SET:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f"<span class="subst">&#123;name&#125;</span> is not a valid name!"</span>)</span><br></pre></td></tr></table></figure><p>更多信息可查阅 Python 官方 wiki：“TimeComplexity - Python Wiki”</p><h4 id="掌握如何快速合并字典"><a href="#掌握如何快速合并字典" class="headerlink" title="掌握如何快速合并字典"></a>掌握如何快速合并字典</h4><p>d1.update(d2)：d1 会变成目标值。</p><p>要想合并字典且不修改原来的值，使用<strong>动态解包表达式</strong>可以更简单地完成操作。</p><p>要实现合并功能，需要用到双星号 ** 运算符来做解包操作。在字典中使用 **dict_obj 表达式，可以动态解包 dict_obj 字典的所有内容，并与当前字典合并。</p><p>解包过程会默认进行<strong>浅拷贝</strong>操作，所以我们可以用它方便地合并两个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="string">'name'</span>: <span class="string">'apple'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="string">'price'</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># d1、d2 原始值不会受影响</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;**d1, **d2&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'apple'</span>, <span class="string">'price'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>除了使用 ** 解包字典，你还可以使用单星号 * 运算符来解包<strong>任何可迭代对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, *range(<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 合并两个列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[*l1, *l2]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>合理利用 * 和 ** 运算符，可以帮助我们高效构建列表与字典对象。</p><p>字典的 | 运算符：Python 3.9 版本中，字典类型新增了对 | 运算符的支持。只要执行 d1 | d2，就能快速拿到两个字典合并后的结果。注：运算顺序不同，会影响最终的合并结果。</p><h4 id="使用有序字典去重"><a href="#使用有序字典去重" class="headerlink" title="使用有序字典去重"></a>使用有序字典去重</h4><p>如果你既需要去重，又想要保留原有顺序，可以使用 OrderedDict 来完成这件事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment"># 调用 fromkeys 方法会创建一个有序字典对象。</span></span><br><span class="line"><span class="comment"># 字典的键来自方法的第一个参数：可迭代对象（此处为 nums 列表），字典的默认值为 None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(OrderedDict.fromkeys(nums).keys())</span><br></pre></td></tr></table></figure><h4 id="别在遍历列表时同步修改"><a href="#别在遍历列表时同步修改" class="headerlink" title="别在遍历列表时同步修改"></a>别在遍历列表时同步修改</h4><h4 id="编写推导式的两个“不要”"><a href="#编写推导式的两个“不要”" class="headerlink" title="编写推导式的两个“不要”"></a>编写推导式的两个“不要”</h4><h5 id="别写太复杂的推导式"><a href="#别写太复杂的推导式" class="headerlink" title="别写太复杂的推导式"></a>别写太复杂的推导式</h5><h5 id="别把推导式当作代码量更少的循环"><a href="#别把推导式当作代码量更少的循环" class="headerlink" title="别把推导式当作代码量更少的循环"></a>别把推导式当作代码量更少的循环</h5><p>推导式的核心意义在于<strong>它会返回值</strong>——一个全新构建的列表，如果你不需要这个新列表，就失去了使用表达式的意义。</p><h4 id="让函数返回-NamedTuple"><a href="#让函数返回-NamedTuple" class="headerlink" title="让函数返回 NamedTuple"></a>让函数返回 NamedTuple</h4><p>对于那种<strong>未来可能会变动的</strong>多返回值函数来说，如果一开始就是用 NamedTuple 类型对返回结果进行建模，改动会变得简单许多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(NamedTuple)</span>:</span></span><br><span class="line">    <span class="string">"""地址信息结果"""</span></span><br><span class="line">    country: str</span><br><span class="line">    province: str</span><br><span class="line">    city: str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">latlon_to_address</span><span class="params">(lat, lon)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Address(</span><br><span class="line">        country=country,</span><br><span class="line">        province=province,</span><br><span class="line">        city=city,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">addr = latlon_to_address(lat, lon)</span><br><span class="line"><span class="comment"># 通过属性名来使用 addr</span></span><br><span class="line"><span class="comment"># addr.country / addr.province / addr.city</span></span><br></pre></td></tr></table></figure><p>假如我们在 Address 里增加了新的返回值 district，已有的函数调用代码也不用进行任何适配性修改，因为函数结果只是多了一个新属性，没有任何破坏性影响。</p><h2 id="第-4-章-条件分支控制流"><a href="#第-4-章-条件分支控制流" class="headerlink" title="第 4 章 条件分支控制流"></a>第 4 章 条件分支控制流</h2><h3 id="基础知识-3"><a href="#基础知识-3" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="分支惯用写法"><a href="#分支惯用写法" class="headerlink" title="分支惯用写法"></a>分支惯用写法</h4><p>当我们编写分支时，第一件要注意的事情，就是不要显式地和布尔值作比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐的写法</span></span><br><span class="line"><span class="comment"># if user.is_active_member() == True:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐写法</span></span><br><span class="line"><span class="comment"># if user.is_active_member():</span></span><br></pre></td></tr></table></figure><p>绝大多数情况下，在分支判断语句里写 == True 都没有必要，删掉它代码会更短也更易读。但这条原则也有例外，比如你确实想让分支仅当值是 True 时才执行。不过即便这样，写 <code>if &lt;expression&gt; == True</code> 仍然是有问题的。</p><h5 id="省略零值判断"><a href="#省略零值判断" class="headerlink" title="省略零值判断"></a>省略零值判断</h5><p>当某个对象作为主角出现在 if 分支里时，解释器会主动对它进行“真值测试”，也就是调用 bool() 函数获取它的布尔值。而在计算布尔值时，每类对象都有着各自的规则，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">0</span>), bool(<span class="number">123</span>)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool([]), bool([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>但请注意，不要因为过度追求简写而引入其他逻辑问题。</p><p>除整型外，其他内置类型的布尔值规则如下：</p><ul><li>布尔值为假：None、0、False、[]、()、{}、set()、frozenset()，等等。</li><li>布尔值为真：非 0 的数值、True、非空的序列、元组、字典，用户定义的类和实例，等等。</li></ul><h5 id="把否定逻辑移入表达式内"><a href="#把否定逻辑移入表达式内" class="headerlink" title="把否定逻辑移入表达式内"></a>把否定逻辑移入表达式内</h5><h5 id="尽可能让三元表达式保持简单"><a href="#尽可能让三元表达式保持简单" class="headerlink" title="尽可能让三元表达式保持简单"></a>尽可能让三元表达式保持简单</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="comment"># true_value if &lt;expression&gt; else false_value</span></span><br><span class="line">language = <span class="string">"python"</span> <span class="keyword">if</span> you.favor(<span class="string">"dynamic"</span>) <span class="keyword">else</span> <span class="string">"golang"</span></span><br></pre></td></tr></table></figure><h4 id="修改对象的布尔值"><a href="#修改对象的布尔值" class="headerlink" title="修改对象的布尔值"></a>修改对象的布尔值</h4><p>当我们把某个对象用于分支判断时，解释器会对它进行“真值测试”，计算它的布尔值，而所有用户自定义的类和类实例的计算结果都是 True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Foo)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Foo())</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>这个现象符合逻辑，但有时会显得有点死板。</p><p>给类实现 __len__ 魔法方法，users 对象就可以直接用于“真值测试”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCollection</span>:</span></span><br><span class="line">    <span class="string">""" 用于保存多个用户的集合工具类 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, users)</span>:</span></span><br><span class="line">        self.items = users</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line"></span><br><span class="line">users = UserCollection([<span class="string">'piglei'</span>, <span class="string">'raymond'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不再需要手动判断对象内部 items 的长度</span></span><br><span class="line"><span class="keyword">if</span> users:</span><br><span class="line">    print(<span class="string">"There's some users in collection"</span>)</span><br></pre></td></tr></table></figure><p>为类定义 __len__ 魔法方法，实际上就是为它实现了 Python 世界的长度协议：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>users = UserCollection([])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(users)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>users = UserCollection([<span class="string">'piglei'</span>, <span class="string">'raymond'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(users)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>Python 在计算这类对象的布尔值时，会受 len(users) 的结果影响——假如长度为 0，布尔值为 False，反之为 True。因此当例子中的 UserCollection 类实现了 __len__ 后，整个条件判断语句就得到了简化。</p><p>不过，定义 __len__ 并非影响布尔值结果的唯一办法。除了 __len__ 以外，还有一个魔法方法 __bool__ 和对象的布尔值息息相关。</p><p>为对象定义 __bool__ 方法后，对它进行布尔值运算会直接返回该方法的调用结果。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScoreJudger</span>:</span></span><br><span class="line">    <span class="string">""" 仅当分数大于 60 时为真 """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.score &gt;= <span class="number">60</span></span><br></pre></td></tr></table></figure><p>假如一个类同时定义了 __len__ 和 __bool__ 两个方法，解释器会优先使用 __bool__ 方法的执行结果。</p><h4 id="与-None-比较时使用-is-运算符"><a href="#与-None-比较时使用-is-运算符" class="headerlink" title="与 None 比较时使用 is 运算符"></a>与 None 比较时使用 is 运算符</h4><p>对于自定义对象来说，它们在进行 == 运算时行为是可操纵的：只要实现类型的 __eq__ 魔法方法即可。</p><p>== 和 is 看上去差不多，但有着本质的区别：</p><ol><li>== 对比两个对象的值是否相等，行为<strong>可被 __eq__ 方法重载</strong>；</li><li>is 判断两个对象是否是内存里的同一个东西，<strong>无法被重载</strong>。</li></ol><p>换句话说，当你在执行 x is y 时，其实就是在判断 id(x) 和 id(y) 的结果是否相等，二者是否是同一个对象。</p><p>除了 None、True、False 这三个内置对象以外，其他类型的对象在 Python 中并不是严格以单例模式存在。因此，仅当你需要判断某个对象是否是 None、True、False 时，使用 is，其他情况下，请使用 ==。</p><p>整型驻留（integer interning）底层优化技术：对于从 -5 到 256 的这些常用小整数， Python 会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时，Python 不会创建任何新的整型对象，而是会返回缓存中的对象。除了整型以外，Python 对字符串也有类似的“驻留”操作。可搜索“Python integer/string interning”。</p><h3 id="案例故事-3"><a href="#案例故事-3" class="headerlink" title="案例故事"></a>案例故事</h3><h4 id="消失的分支"><a href="#消失的分支" class="headerlink" title="消失的分支"></a>消失的分支</h4><h5 id="使用-bisect-优化范围类分支判断"><a href="#使用-bisect-优化范围类分支判断" class="headerlink" title="使用 bisect 优化范围类分支判断"></a>使用 bisect 优化范围类分支判断</h5><p>bisect 是 Python 内置的二分算法模块，它有一个同名函数 bisect，可以用来在有序列表里做二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rank</span><span class="params">(self)</span>:</span></span><br><span class="line">    breakpoints = (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8.5</span>)</span><br><span class="line">    grades = (<span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line">    index = bisect.bisect(breakpoints, float(self.rating))</span><br><span class="line">    <span class="keyword">return</span> grades[index]</span><br></pre></td></tr></table></figure><h5 id="使用字典优化分支"><a href="#使用字典优化分支" class="headerlink" title="使用字典优化分支"></a>使用字典优化分支</h5><p>例子中的条件分支有两个明显特定：</p><ol><li>它用到的条件表达式都非常类似，都是对 sorting_type 做等值判断（sorting_type == ‘name’）。</li><li>它的每个分支的内部逻辑也大同小异——都是调用 sorted() 函数，只是 key 和 reverse 参数略有不同。</li></ol><p>当代码里的条件分支同时满足两个条件，我们就可以用字典类型来简化它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sorted_movies</span><span class="params">(movies, sorting_type)</span>:</span></span><br><span class="line">    <span class="string">""" 对电影列表进行排序并返回</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param movies: Movie 对象列表</span></span><br><span class="line"><span class="string">    :param sorting_type: 排序选项，可选项</span></span><br><span class="line"><span class="string">        name（名称）、rating（评分）、year（年份）、random（随机乱序）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sorting_algos = &#123;</span><br><span class="line">        <span class="comment"># sorting_type: (key_func, reverse)</span></span><br><span class="line">        <span class="string">'name'</span>: (<span class="keyword">lambda</span> movie: movie.name.lower(), <span class="literal">False</span>),</span><br><span class="line">        <span class="string">'rating'</span>: (<span class="keyword">lambda</span> movie: float(movie.rating), <span class="literal">True</span>),</span><br><span class="line">        <span class="string">'year'</span>: (<span class="keyword">lambda</span> movie: movie.year, <span class="literal">True</span>),</span><br><span class="line">        <span class="string">'random'</span>: (<span class="keyword">lambda</span> movie: random.random(), <span class="literal">False</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        key_func, reverse = sorting_algos[sorting_type]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f'Unkown sorting type: <span class="subst">&#123;sorting_type&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    sorted_movies = sorted(movies, key=key_func, reverse=reverse)</span><br><span class="line">    <span class="keyword">return</span> sorted_movies</span><br></pre></td></tr></table></figure><h5 id="优化成果"><a href="#优化成果" class="headerlink" title="优化成果"></a>优化成果</h5><p>除了故事中展现的两种方式外，面向对象的多态也是消除条件分支代码的一大利器。</p><h3 id="编程建议-3"><a href="#编程建议-3" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="尽量避免多层分支嵌套"><a href="#尽量避免多层分支嵌套" class="headerlink" title="尽量避免多层分支嵌套"></a>尽量避免多层分支嵌套</h4><p><strong>要竭尽所能地避免分支嵌套</strong>。</p><p>在“Python 之禅”里有一句：“扁平优于嵌套”（Flat is better than nested），这刚好说明了把嵌套分支改为扁平地重要性。</p><h4 id="别写太复杂的条件表达式"><a href="#别写太复杂的条件表达式" class="headerlink" title="别写太复杂的条件表达式"></a>别写太复杂的条件表达式</h4><h4 id="尽量降低分支内代码地相似性"><a href="#尽量降低分支内代码地相似性" class="headerlink" title="尽量降低分支内代码地相似性"></a>尽量降低分支内代码地相似性</h4><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    create_user_profile(</span><br><span class="line">        username=data.username,</span><br><span class="line">        gender=data.gender,</span><br><span class="line">        email=data.email,</span><br><span class="line">        age=data.age,</span><br><span class="line">        address=data.address,</span><br><span class="line">        points=<span class="number">0</span>,</span><br><span class="line">        created=now(),    </span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    update_user_profile(</span><br><span class="line">        username=data.username,</span><br><span class="line">        gender=data.gender,</span><br><span class="line">        email=data.email,</span><br><span class="line">        age=data.age,</span><br><span class="line">        address=data.address,</span><br><span class="line">        updated=now(),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>为了降低这种相似性，我们可以使用 Python 函数地动态关键字参数（**kwargs）特性，简化一下上面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.no_profile_exists:</span><br><span class="line">    _update_or_create = create_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'points'</span>: <span class="number">0</span>, <span class="string">'created'</span>: now()&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    _update_or_create = update_user_profile</span><br><span class="line">    extra_args = &#123;<span class="string">'updated'</span>: now()&#125;</span><br><span class="line"></span><br><span class="line">_update_or_create(</span><br><span class="line">    username=data.username,</span><br><span class="line">    gender=data.gender,</span><br><span class="line">    email=data.email,</span><br><span class="line">    age=data.age,</span><br><span class="line">    address=data.address,</span><br><span class="line">    **extra_args,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="使用“德摩根定律”"><a href="#使用“德摩根定律”" class="headerlink" title="使用“德摩根定律”"></a>使用“德摩根定律”</h4><p>“德摩根定律”：not A or not B 等价于 not (A and B)。</p><h4 id="使用-all-any-函数构建条件表达式"><a href="#使用-all-any-函数构建条件表达式" class="headerlink" title="使用 all()/any() 函数构建条件表达式"></a>使用 all()/any() 函数构建条件表达式</h4><p>all()/any()：接收一个可迭代对象作为参数，返回一个布尔值表达式。</p><ul><li>all(iterable)：仅当 iterable 中所有成员地布尔值都为真时返回 True，否则返回 False。</li><li>any(iterable)：只要 iterable 中任何一个成员的布尔值为真就返回 True，否则返回 False。</li></ul><p>例：判断一个列表里的所有数字是不是都大于 10:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_numbers_gt_10_2</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(numbers) <span class="keyword">and</span> all(n &gt; <span class="number">10</span> <span class="keyword">for</span> n <span class="keyword">in</span> numbers)</span><br></pre></td></tr></table></figure><h4 id="留意-and-和-or-的运算优先级"><a href="#留意-and-和-or-的运算优先级" class="headerlink" title="留意 and 和 or 的运算优先级"></a>留意 and 和 or 的运算优先级</h4><h4 id="避开-or-运算符的陷阱"><a href="#避开-or-运算符的陷阱" class="headerlink" title="避开 or 运算符的陷阱"></a>避开 or 运算符的陷阱</h4><p>or 运算符最有趣的地方是它的“短路求值”特性。</p><p>使用 a or b 来表示“a 为空时用 b 代替”。但在这种写法下，藏着一个陷阱：因为 or 计算的是变量的布尔真假值，所以不光是 None，0、[]、{} 以及其他所有布尔值为假的东西，都会在 or 运算中被忽略。</p><h2 id="第-5-章-异常与错误处理"><a href="#第-5-章-异常与错误处理" class="headerlink" title="第 5 章 异常与错误处理"></a>第 5 章 异常与错误处理</h2><h3 id="基础知识-4"><a href="#基础知识-4" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="优先使用异常捕获"><a href="#优先使用异常捕获" class="headerlink" title="优先使用异常捕获"></a>优先使用异常捕获</h4><p>LBYL (look before you leap)：常被翻译为“三思而后行”。</p><p>EAFP (easier to ask for forgiveness than permission)：可直译为“获取原谅比许可简单”。</p><p>和 LBYL 相比，EAFP 编程风格更为简单直接，它总是直奔主流程而去，把意外情况都放在异常处理 try/except 块内消化掉。</p><p>每当直觉驱使你写下 if/else 来进行错误分支判断时，请先把这份冲动放一放，考虑用 try 来捕获异常是不是更合适。</p><h4 id="try-语句常用知识"><a href="#try-语句常用知识" class="headerlink" title="try 语句常用知识"></a>try 语句常用知识</h4><h5 id="把更精确的-except-语句放在前面"><a href="#把更精确的-except-语句放在前面" class="headerlink" title="把更精确的 except 语句放在前面"></a>把更精确的 except 语句放在前面</h5><p>Python 内置异常类之间存在许多继承关系。比如：BaseException -&gt; Exception -&gt; LookupError -&gt; KeyError，（BaseException 是一切异常类的父类，甚至包括 KeyboardInterrupt 异常）。</p><h5 id="使用-else-分支"><a href="#使用-else-分支" class="headerlink" title="使用 else 分支"></a>使用 else 分支</h5><p>异常捕获语句里面的 else 表示：仅当 try 语句块里没有抛出任何异常时，才执行 else 分支下的内容，效果就像在 try 最后增加一个标记变量一样。</p><h5 id="使用空-raise-语句"><a href="#使用空-raise-语句" class="headerlink" title="使用空 raise 语句"></a>使用空 raise 语句</h5><p>在处理异常时，有时我们可能仅仅是想记录某个异常，然后把它重新抛出，交由上层处理。这时，不带任何参数的 raise 语句可以派上用场：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">incr_by_key</span><span class="params">(d, key)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        d[key] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        print(<span class="string">f'key <span class="subst">&#123;key&#125;</span> does not exists, re-raise the exception'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>当一个空的 raise 语句出现在 except 块里时，它会原封不动得重新抛出当前异常。</p><h4 id="抛出异常，而不是返回错误"><a href="#抛出异常，而不是返回错误" class="headerlink" title="抛出异常，而不是返回错误"></a>抛出异常，而不是返回错误</h4><p>虽然我们鼓励使用异常，但异常总是会不可避免地让人“感到惊讶”。所以，最好在函数文档里说明可能抛出的异常类型。</p><p>不同于返回值，异常在被捕获前不断往调用栈上层汇报。因此 create_item() 的直接调用方也可以完全不处理 CreateItemError，而交由更上层处理。异常的这个特点给了我们更多灵活性，也同时也带来了更大的风险。具体来说，加入程序缺少了一个顶级的统一异常处理逻辑，那么某个被所有人忽视了的异常可能会层层上报，最终弄垮整个程序。</p><h4 id="使用上下文管理器"><a href="#使用上下文管理器" class="headerlink" title="使用上下文管理器"></a>使用上下文管理器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 with 打开文件，文件描述符会在作用域结束后自动被释放</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'foo.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    content = fp.read()</span><br></pre></td></tr></table></figure><p>with 是个神奇的关键字，它可以在代码中开辟一段由它管理的上下文，并控制程序在进入和退出这段上下文时的行为。</p><p>并非所有对象都能像 open(‘foo.txt’) 一样配合 with 使用，只有满足<strong>上下文管理器</strong>（context manager）协议的对象才行。要创建一个上下文管理器，只要实现 __enter__ 和 __exit__ 两个魔法方法即可。</p><p>上下文管理器功能强大、用处很多，其中最常见的用处之一，就是简化异常处理工作。</p><h5 id="用于替代-finally-语句清理资源"><a href="#用于替代-finally-语句清理资源" class="headerlink" title="用于替代 finally 语句清理资源"></a>用于替代 finally 语句清理资源</h5><p>当程序使用 with 进入一段上下文后，不论里面发生了什么，它在退出这段上下文代码块时，<strong>必定</strong>会调用上下文管理器的 __exit__ 方法，就和 finally 语句的行为一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">create_conn_obj</span>:</span></span><br><span class="line">    <span class="string">""" 创建连接对象，并在退出上下文时自动关闭 """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port, timeout=timeout)</span>:</span></span><br><span class="line">        self.conn = create_conn(host, port, timeout=timeout)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.conn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        <span class="comment"># __exit__ 会在管理器退出时调用</span></span><br><span class="line">        self.conn.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>使用 create_conn_obj 可以创建会自动关闭的连接对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用上下文管理器创建连接</span></span><br><span class="line"><span class="keyword">with</span> create_conn_obj(host, port, timeout=<span class="literal">None</span>) <span class="keyword">as</span> conn:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn.send.text(<span class="string">'Hello, world!'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">f'Unable to use connection: <span class="subst">&#123;e&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h5 id="用于忽略异常"><a href="#用于忽略异常" class="headerlink" title="用于忽略异常"></a>用于忽略异常</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ignore_closed</span>:</span></span><br><span class="line">    <span class="string">""" 忽略已经关闭的连接 """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_type == AlreadyClosedError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>当你想忽略掉 AlreadyClosedError 异常时，只要把代码用 with 语句包裹起来即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ignore_closed():</span><br><span class="line">    close_conn(conn)</span><br></pre></td></tr></table></figure><p>通过 with 实现的“忽略异常”功能，主要利用了上下文管理器的 __exit__ 方法。</p><p>__exit__ 接收三个参数：exc_type，exc_value 和 traceback。</p><p>在代码执行时，假如 with 管辖的上下文内没有抛出任何异常，那么当解释器触发 __exit__ 方法时，上面的三个参数的值都是 None；但如果有异常抛出，这三个参数就会变成该异常的具体内容。</p><ol><li>exc_type：异常的类型。</li><li>exc_value：异常对象。</li><li>traceback：错误的堆栈对象。</li></ol><p>此时，程序的行为取决于 __exit__ 方法的返回值。如果 __exit__ 返回了 True，那么这个异常就会被当前的 with 语句压制住，不再继续抛出，达到“忽略异常”的效果；如果 __exit__ 返回了 False，那这个异常就会被正常抛出，交由调用方处理。</p><p>如果你在真实的项目中要忽略某类异常，可以直接使用标准库模块 contextlib 里的 suppress 函数，它提供了现成的“忽略异常”功能。</p><h5 id="使用-contextmanager-装饰器"><a href="#使用-contextmanager-装饰器" class="headerlink" title="使用 contextmanager 装饰器"></a>使用 contextmanager 装饰器</h5><p>@contextmanger 位于内置模块 contextlib 下，它可以把任何一个生成器函数直接转换为一个上下文管理器。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_conn_obj</span><span class="params">(host, port, timeout=None)</span>:</span></span><br><span class="line">    <span class="string">""" 创建连接对象，并在退出上下文时自动关闭 """</span></span><br><span class="line">    conn = create_conn(host, port, timeout=timeout)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 以 yield 为界，yield 前的逻辑会在进入管理器时执行（类似于 __enter__），yield 后的逻辑会在退出管理器时执行（类似于 __exit__）</span></span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 如果要在上下文管理器内处理异常，必须用 try 语句块包裹 yield 语句</span></span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure><p>在日常工作中，我们用到的大多数上下文管理器，可以直接通过“生成器函数 + @contextmanager”的方式来定义，这比创建一个符合协议的类要简单得多。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/317360115" target="_blank" rel="noopener">摘自网络</a>：上下文管理器</p></blockquote><h3 id="案例故事-4"><a href="#案例故事-4" class="headerlink" title="案例故事"></a>案例故事</h3><h4 id="提前崩溃也挺好"><a href="#提前崩溃也挺好" class="headerlink" title="提前崩溃也挺好"></a>提前崩溃也挺好</h4><h4 id="异常与抽象一致性"><a href="#异常与抽象一致性" class="headerlink" title="异常与抽象一致性"></a>异常与抽象一致性</h4><h3 id="编程一致性"><a href="#编程一致性" class="headerlink" title="编程一致性"></a>编程一致性</h3><h4 id="不要随意忽略异常"><a href="#不要随意忽略异常" class="headerlink" title="不要随意忽略异常"></a>不要随意忽略异常</h4><h4 id="不要手动做数据校验"><a href="#不要手动做数据校验" class="headerlink" title="不要手动做数据校验"></a>不要手动做数据校验</h4><p>我们要把“输入数据校验”当作一个独立的领域，挑选更适合的模块来完成这项工作。</p><p>在数据校验这块，pydantic 模块是一个不错的选择：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, conint, validationError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberInput</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    <span class="comment"># 使用类型注解 conint 定义 number 属性的取值范围</span></span><br><span class="line">    number: conint(ge=<span class="number">0</span>, le=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_a_number_with_pydantic</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        number = input(<span class="string">'Please input a number (0-100):'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        number_input = NumberInput(number=number)</span><br><span class="line">    <span class="keyword">except</span> ValidationError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    number = number_input.number</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'Your number is <span class="subst">&#123;number&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>假如你在开发 Web 应用，数据校验工作通常来说比较容易。比如 Django 框架就有自己的表单验证模块，Flask 也可以使用 WTForms 模块来进行数据校验。</p><h4 id="抛出可区分的异常"><a href="#抛出可区分的异常" class="headerlink" title="抛出可区分的异常"></a>抛出可区分的异常</h4><p>当开发者编写自定义异常类时，似乎不需要遵循太多原则。常见的几条是：要继承 Exception 而不是 BaseException；异常类名最好以 Error 或 Exception结尾等。但除了这些以外，设计异常的人其实还需要考虑一个重要指标——调用方是否能清晰区分各种异常。</p><h4 id="不要使用-assert-来检查参数合法性"><a href="#不要使用-assert-来检查参数合法性" class="headerlink" title="不要使用 assert 来检查参数合法性"></a>不要使用 assert 来检查参数合法性</h4><p>assert 是 Python 用来编写断言语句的关键字，它可以用来测试某个表达式是否成立。当 assert 后面的表达式运行结果为 False 的时候，断言语句会马上抛出 AssertionError 异常。</p><p>assert 是一个专供开发者调试程序的关键字。它所提供的断言检查，可以在执行 Python 时使用 -O 直接跳过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -O</span><br><span class="line"><span class="comment"># -O 选项表示让所有 assert 断言语句无效化</span></span><br><span class="line"><span class="comment"># 开启此选项后，下面的 assert 语句不会抛出任何异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>因此，不要拿 assert 来做参数校验，用 raise 语句来代替它吧。</p><h4 id="无须处理是最好的错误处理"><a href="#无须处理是最好的错误处理" class="headerlink" title="无须处理是最好的错误处理"></a>无须处理是最好的错误处理</h4><p>在设计 API 时，需要慎重考虑是否真的有必要抛出错误。</p><p><strong>空对象模式</strong>：“空对象模式”就是本该返回 None 值或抛出异常时，返回一个符合正常结果接口的特制“空类型对象”来代替，以此免去调用方的错误处理工作。</p><h2 id="第-6-章-循环与可迭代对象"><a href="#第-6-章-循环与可迭代对象" class="headerlink" title="第 6 章 循环与可迭代对象"></a>第 6 章 循环与可迭代对象</h2><p>在 Python 中，我们可以用两种方式编写循环：for 和 while。for 是我们最常用到的循环关键字，它的语法是 for &lt;item&gt; in &lt;iterable&gt;，需要配合一个可迭代对象 iterable 使用。</p><p>要把循环代码写得漂亮，有时关键不在循环自身，而在于另一个用来配合循环的主角：可迭代对象。</p><h3 id="基础知识-5"><a href="#基础知识-5" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="迭代器与可迭代对象"><a href="#迭代器与可迭代对象" class="headerlink" title="迭代器与可迭代对象"></a>迭代器与可迭代对象</h4><h5 id="iter-与-next-函数"><a href="#iter-与-next-函数" class="headerlink" title="iter() 与 next() 函数"></a>iter() 与 next() 函数</h5><p>iter() 函数和 bool() 函数很像，调用 iter() 会尝试返回一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&lt;list_iterator object at <span class="number">0x101a82d90</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(<span class="string">'foo'</span>)</span><br><span class="line">&lt;str_iterator object at <span class="number">0x101a99ed0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">in</span> <span class="keyword">not</span> iterable</span><br></pre></td></tr></table></figure><p>什么是<strong>迭代器（iterator）</strong>？顾名思义，这是一种帮助你迭代其他对象的对象。迭代器最新鲜的特征是：不断对它执行 next() 函数会返回下一次迭代结果。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_l = iter(l)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter_l</span><br><span class="line">&lt;list_iterator object <span class="number">0x101a8c6d0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iter_l)</span><br><span class="line"><span class="string">'foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iter_l)</span><br><span class="line"><span class="string">'bar'</span></span><br></pre></td></tr></table></figure><p>当你对迭代器执行 iter() 函数，尝试获取迭代器的迭代器对象时，返回的结果一定是迭代器本身。</p><p>当你使用 for 循环遍历某个可迭代对象时，其实是先调用了 iter() 拿到它的迭代器，然后不断地用 next() 从迭代器中获取值。</p><p>也就是说，下面这段 for 循环代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foobar'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>可以翻译成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iterator = iter(names)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        name = next(iterator)</span><br><span class="line">        print(name)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h5 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h5><p>要自定义一个迭代器类型，关键在于实现下面这两个魔法方法。</p><ul><li>__iter__：调用 iter() 时触发，迭代器对象总是返回自身。</li><li>__next__：调用 next() 时触发，通过 return 来返回结果，没有更多内容就抛出 StopIteration 异常，<strong>会在迭代过程中多次触发</strong>。</li></ul><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range7</span>:</span></span><br><span class="line">    <span class="string">""" 生成某个范围内可被 7 整除或包含 7 的整数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param start: 开始数字</span></span><br><span class="line"><span class="string">    :param end: 结束数字</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line">        self.current = start</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current &gt;= self.end:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.num_is_valid(self.current):</span><br><span class="line">                ret = self.current</span><br><span class="line">                self.current += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_is_valid</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">7</span> == <span class="number">0</span> <span class="keyword">or</span> <span class="string">'7'</span> <span class="keyword">in</span> str(num)</span><br></pre></td></tr></table></figure><h5 id="区分迭代器与可迭代对象"><a href="#区分迭代器与可迭代对象" class="headerlink" title="区分迭代器与可迭代对象"></a>区分迭代器与可迭代对象</h5><p>迭代器是可迭代对象的一种。它最常出现的场景是在迭代其他对象时，作为一种介质或工具对象存在——就像调用 iter([]) 时返回的 list_iterator。每个迭代器都对应一次完整的迭代过程，因此它自身必须保存与当前迭代相关的状态——迭代位置。</p><p>一个合法的迭代器，必须同时实现 __iter__ 和 __next__ 两个魔法方法。</p><p>相比之下，可迭代对象的定义则宽泛许多。判断一个对象 obj 是否可迭代的唯一标准，就是调用 iter(obj)，然后看结果是不是一个迭代器。因此，可迭代对象只需要实现 __iter__ 方法，不一定得实现 __next__ 方法。</p><p>所以，如果想让 Range7 对象在每次迭代时都返回完整结果，我们必须把现在的代码拆成两部分：<br>可迭代类型 Range7 和 迭代器类型 Range7Iterator。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range7</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Range7Iterator(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range7Iterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, range_obj)</span>:</span></span><br><span class="line">        self.range_obj = range_obj</span><br><span class="line">        self.current = range_obj.start</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.current &gt;= self.range_obj.end:</span><br><span class="line">                <span class="keyword">raise</span> StopIteration</span><br><span class="line">            <span class="keyword">if</span> self.num_is_valid(self, current):</span><br><span class="line">                ret = self.current</span><br><span class="line">                self.current += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_is_valid</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">7</span> == <span class="number">0</span> <span class="keyword">or</span> <span class="string">'7'</span> <span class="keyword">in</span> str(num)</span><br></pre></td></tr></table></figure><p>最后，总结一下迭代器与可迭代对象的区别：</p><ul><li>可迭代对象不一定是迭代器，但迭代器一定是可迭代对象；</li><li>对可迭代对象使用 iter() 方法会返回迭代器，迭代器则会返回其自身；</li><li>每个迭代器的被迭代过程是一次性的，可迭代对象则不一定；</li><li>可迭代对象只需要实现 __iter__ 方法，而迭代器要额外实现 __next__ 方法。</li></ul><p>可迭代对象与 __getitem__：略</p><h5 id="生成器是迭代器"><a href="#生成器是迭代器" class="headerlink" title="生成器是迭代器"></a>生成器是迭代器</h5><p>生成器是一种“懒惰的”可迭代对象，使用它来替代传统列表可以节约内存，提升执行效率。</p><p>但除此之外，生成器还是一种简化的迭代器实现，使用它可以大大降低实现传统迭代器的编码成本。因此在平时，我们基本不需要通过 __iter__ 和 __next__ 来实现迭代器，只要写上几个 yield 就行。</p><p>如果利用生成器，上面的 Range7Iterator 可以改写成一个只有 5 行代码的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">range_7_gen</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    num = start</span><br><span class="line">    <span class="keyword">while</span> num &lt; end:</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span> <span class="keyword">and</span> (num % <span class="number">7</span> == <span class="number">0</span> <span class="keyword">or</span> <span class="string">'7'</span> <span class="keyword">in</span> str(num)):</span><br><span class="line">            <span class="keyword">yield</span> num</span><br><span class="line">        num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们可以使用 iter() 和 next() 函数来验证“生成器就是迭代器”这个事实：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = range_7_gen(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(nums)</span><br><span class="line">&lt;generator object range_7_gen at <span class="number">0x10404b2e0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(nums) <span class="keyword">is</span> nums</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(nums)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><p>生成器，利用简单的语法，大大降低了迭代器的使用门槛，是优化循环代码时最得力的帮手。</p><h4 id="修饰可迭代对象优化循环"><a href="#修饰可迭代对象优化循环" class="headerlink" title="修饰可迭代对象优化循环"></a>修饰可迭代对象优化循环</h4><p>“修饰可迭代对象”是指用生成器（或普通的迭代器）在循环外部包装原本的循环主体，完成一些原本必须在循环内部执行的工作——比如过滤特定成员、提供额外结果等，以此简化循环代码。</p><p>除了自定义修饰函数外，你还可以直接使用标准库模块 itertools 里的许多现成工具。</p><h4 id="使用-itertools-模块优化循环"><a href="#使用-itertools-模块优化循环" class="headerlink" title="使用 itertools 模块优化循环"></a>使用 itertools 模块优化循环</h4><h5 id="使用-product-扁平化多层嵌套循环"><a href="#使用-product-扁平化多层嵌套循环" class="headerlink" title="使用 product() 扁平化多层嵌套循环"></a>使用 product() 扁平化多层嵌套循环</h5><p>product() 接收多个可迭代对象作为参数，然后根据它们的笛卡儿积不断生成结果。</p><h5 id="使用-islice-实现循环内隔行运算"><a href="#使用-islice-实现循环内隔行运算" class="headerlink" title="使用 islice() 实现循环内隔行运算"></a>使用 islice() 实现循环内隔行运算</h5><p>islice(seq, start, end, step) 函数和数组切片操作（list[start:stop:step]）接受的参数几乎完全一致。如果需要在循环内部实现隔行处理，只要设置第三个参数 step（递进步长）的值为 2 即可。</p><h5 id="使用-takewhile-替代-break-语句"><a href="#使用-takewhile-替代-break-语句" class="headerlink" title="使用 takewhile() 替代 break 语句"></a>使用 takewhile() 替代 break 语句</h5><p>takewhile(predicate, iterable) 会在迭代第二个参数 iterable 的过程中，不断使用当前值作为参数调用 predicate() 函数，并对返回结果进行真值测试，如果为 True，则返回当前值并继续迭代，否则立即中断本次迭代。</p><p>除了上面这三个函数以外，itertools 还有其他一些有意义的工具函数，它们都可以搭配循环使用，比如用 chain() 函数可以扁平化双层嵌套循环、用 zip_longest() 函数可以同时遍历多个对象，等等。</p><h4 id="循环语句的-else-关键字"><a href="#循环语句的-else-关键字" class="headerlink" title="循环语句的 else 关键字"></a>循环语句的 else 关键字</h4><p>for 循环（和 while 循环）后的 else 关键字，代表如果循环正常结束（没有碰到任何 break），便执行该分支内的语句。</p><h3 id="案例故事-5"><a href="#案例故事-5" class="headerlink" title="案例故事"></a>案例故事</h3><h4 id="数字统计任务"><a href="#数字统计任务" class="headerlink" title="数字统计任务"></a>数字统计任务</h4><h5 id="读取文件的标准做法"><a href="#读取文件的标准做法" class="headerlink" title="读取文件的标准做法"></a>读取文件的标准做法</h5><h5 id="使用-while-循环加-read-方法分块读取"><a href="#使用-while-循环加-read-方法分块读取" class="headerlink" title="使用 while 循环加 read() 方法分块读取"></a>使用 while 循环加 read() 方法分块读取</h5><p>与直接用循环迭代文件对象不同，每次调用 file.read(chunk_size)，会马上读取从当前游标位置往后chunk_size 大小的文件内容，不必等待任何换行符出现。</p><h5 id="iter-的另一个用法"><a href="#iter-的另一个用法" class="headerlink" title="iter() 的另一个用法"></a>iter() 的另一个用法</h5><p>当我们以 iter(callable, sentinel) 的方式调用 iter() 函数时，会拿到一个特殊的迭代器对象。用循环遍历这个迭代器，会不断返回调用 callable() 的结果，假如结果等于 sentinel，迭代过程中止。</p><h5 id="按职责拆解循环体代码"><a href="#按职责拆解循环体代码" class="headerlink" title="按职责拆解循环体代码"></a>按职责拆解循环体代码</h5><p>要解耦循环体，生成器（或迭代器）是首选。试着把代码按职责分类，抽象成独立的生成器（或迭代器）吧。</p><h3 id="编程建议-4"><a href="#编程建议-4" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="中断嵌套循环的正确方式"><a href="#中断嵌套循环的正确方式" class="headerlink" title="中断嵌套循环的正确方式"></a>中断嵌套循环的正确方式</h4><p>Python 语言不支持“带标签的 break”语句，无法用一个 break 跳出多层循环。</p><p>如果想快速从嵌套循环里跳出，可以把循环代码拆分成一个新函数，然后直接使用 return。</p><h4 id="巧用-next-函数"><a href="#巧用-next-函数" class="headerlink" title="巧用 next() 函数"></a>巧用 next() 函数</h4><p>例：假如有一个字典 d，需要拿到它的第一个 key：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(iter(d.keys()))</span><br><span class="line"><span class="string">'foo'</span></span><br></pre></td></tr></table></figure><p>又例：假设有一个装了非常多整数的列表对象 numbers，我需要找到里面第一个可以被 7 整除的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">42</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(i <span class="keyword">for</span> i <span class="keyword">in</span> numbers <span class="keyword">if</span> i % <span class="number">7</span> == <span class="number">0</span>))</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure><h4 id="当心已被耗尽的迭代器"><a href="#当心已被耗尽的迭代器" class="headerlink" title="当心已被耗尽的迭代器"></a>当心已被耗尽的迭代器</h4><p>在平时，你需要将生成器（迭代器）的“可被一次性耗尽”特点铭记于心，避免写出由它所导致的 bug。假如要重复使用一个生成器，可以调用 list() 函数将它转成列表后再使用。</p><p>除了生成器函数、生成器表达式以外，人们还常常忽略内置的 map()、filter() 函数也会返回一个一次性的迭代器对象。在使用这些函数时，也请务必当心。</p><h2 id="第-7-章-函数"><a href="#第-7-章-函数" class="headerlink" title="第 7 章 函数"></a>第 7 章 函数</h2><p>除了 def 以外，你还可以使用 lambda 关键字定义一个匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br></pre></td></tr></table></figure><p>函数在 Python 中是一等对象，这意味着我们可以把函数自身作为函数参数来使用。最常用的内置排序函数 sorted() 就利用了这个特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">13</span>, <span class="number">16</span>, <span class="number">21</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(l, key=<span class="keyword">lambda</span> x: x % <span class="number">3</span>)</span><br><span class="line">[<span class="number">21</span>, <span class="number">3</span>, <span class="number">13</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><h3 id="基础知识-6"><a href="#基础知识-6" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="函数参数的常用技巧"><a href="#函数参数的常用技巧" class="headerlink" title="函数参数的常用技巧"></a>函数参数的常用技巧</h4><h5 id="别将可变类型作为参数默认值"><a href="#别将可变类型作为参数默认值" class="headerlink" title="别将可变类型作为参数默认值"></a>别将可变类型作为参数默认值</h5><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_value</span><span class="params">(value, items=[])</span>:</span></span><br><span class="line">    items.append(value)</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>这样的函数看上去没什么问题，但当你多次调用它以后，就会发现函数的行为和预想的不太一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>append_value(<span class="string">'foo'</span>)</span><br><span class="line">[<span class="string">'foo'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>append_value(<span class="string">'bar'</span>)</span><br><span class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br></pre></td></tr></table></figure><p>这是因为 Python 函数的<strong>参数默认值只会在函数定义阶段被创建一次</strong>，之后不论再调用多少次，函数内拿到的默认值都是同一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 __defaults__属性可以直接获取函数的参数默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>append_value.__defaults__[<span class="number">0</span>]</span><br><span class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>append_value.__defaults__.append(<span class="string">'baz'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>append_value(<span class="string">'value'</span>)</span><br><span class="line">[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'value'</span>]</span><br></pre></td></tr></table></figure><p>为了规避这个问题，使用 None 来替代可变类型默认值是比较常见的做法。</p><h5 id="定义特殊对象来区分是否提供了默认参数"><a href="#定义特殊对象来区分是否提供了默认参数" class="headerlink" title="定义特殊对象来区分是否提供了默认参数"></a>定义特殊对象来区分是否提供了默认参数</h5><p>在无法区分调用方是否<strong>真的</strong>提供了这个默认参数时，最常见的做法是定义一个特殊对象（标记变量）作为参数默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义标记变量</span></span><br><span class="line"><span class="comment"># object 通常不会单独使用，但是拿来做这种标记变量刚刚好</span></span><br><span class="line">_not_set = object()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bump_values</span><span class="params">(value, extra=_not_set)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> extra <span class="keyword">is</span> _not_set:</span><br><span class="line">        <span class="comment"># 调用方没有传递 extra 参数</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>相比 None，_not_set 是一个独一无二、无法随意获取的标记值。假如函数在执行时判断 extra 的值等于 _not_set，那我们基本可以认定：调用方没有提供 extra 参数。</p><h5 id="定义仅限关键字参数"><a href="#定义仅限关键字参数" class="headerlink" title="定义仅限关键字参数"></a>定义仅限关键字参数</h5><p>Python 里的函数不光支持通过有序<strong>位置参数</strong>（positional argument）调用，还能指明参数名，通过<strong>关键字参数</strong>（keyword argument）的方式调用。</p><p>虽然关键字参数调用模式很有用，但有一个美中不足之处：它只是调用函数时的一种可选方式，无法成为强制要求。不过，我们可以用一种特殊的参数定义语法来弥补这个不足：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_users</span><span class="params">(limit, offset, *, min_followers_count, include_profile)</span>:</span></span><br></pre></td></tr></table></figure><p>通过在参数列表中插入 * 符号，该符号<strong>后</strong>的所有参数都变成了“仅限关键字参数”（keyword-only argument）。如果函数调用方仍然想用位置参数来提供这些参数，程序就会抛出错误。</p><p>通过在参数列表中插入 \ 符号，该符号<strong>后</strong>的所有参数都变成了“仅限位置参数”（positional-only argument）。</p><h4 id="函数返回的常见模式"><a href="#函数返回的常见模式" class="headerlink" title="函数返回的常见模式"></a>函数返回的常见模式</h4><h5 id="尽量只返回一种类型"><a href="#尽量只返回一种类型" class="headerlink" title="尽量只返回一种类型"></a>尽量只返回一种类型</h5><h5 id="谨慎返回-None-值"><a href="#谨慎返回-None-值" class="headerlink" title="谨慎返回 None 值"></a>谨慎返回 None 值</h5><p>当我们需要让函数返回 None 值，主要是下面 3 种情况：</p><ul><li>操作类函数的默认返回值<br>None 是不带任何 return 语句的函数的默认返回值。</li><li>意料之中的缺失值</li><li>在执行失败时代表“错误”<br>此情况可能并不可取，用抛出异常来代替 None 会更合理。</li></ul><p>适合返回 None 的函数需要满足以下两个特点：</p><ol><li>函数的名称和参数必须表达“结果可能缺失”的意思；</li><li>如果函数执行无法产生结果，调用方也并不关心具体原因。</li></ol><h5 id="早返回，多返回"><a href="#早返回，多返回" class="headerlink" title="早返回，多返回"></a>早返回，多返回</h5><h4 id="常用函数模块：functools"><a href="#常用函数模块：functools" class="headerlink" title="常用函数模块：functools"></a>常用函数模块：functools</h4><p>functools 是一个专门用来处理函数的内置模块。</p><h5 id="functools-partial"><a href="#functools-partial" class="headerlink" title="functools.partial()"></a>functools.partial()</h5><h5 id="functools-lru-cache"><a href="#functools-lru-cache" class="headerlink" title="functools.lru_cache()"></a>functools.lru_cache()</h5><p>除了 partial() 和 lru_cache() 以外，functools 模块里还有许多有趣的函数工具，比如 wraps()、reduce() 等。</p><h3 id="案例故事-6"><a href="#案例故事-6" class="headerlink" title="案例故事"></a>案例故事</h3><p>在<strong>函数式编程</strong>（functional programming）领域，有一个术语<strong>纯函数</strong>（pure function）。它最大的特点是，假如输入参数相同，输出结果也一定相同，不受任何其他因素影响。换句话说，纯函数是一种无状态的函数。</p><h4 id="函数与状态"><a href="#函数与状态" class="headerlink" title="函数与状态"></a>函数与状态</h4><h5 id="热身运动"><a href="#热身运动" class="headerlink" title="热身运动"></a>热身运动</h5><p>re.sub(pattern, repl, string, count, flags) 是正则表达式模块所提供的字符串替换函数。</p><h5 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h5><h5 id="给函数加上状态：全局变量"><a href="#给函数加上状态：全局变量" class="headerlink" title="给函数加上状态：全局变量"></a>给函数加上状态：全局变量</h5><p>可使用 global 关键字声明一个全局变量。但用全局变量保存状态，其实是写代码时最应该避免的事情之一。</p><h5 id="给函数加上状态：闭包"><a href="#给函数加上状态：闭包" class="headerlink" title="给函数加上状态：闭包"></a>给函数加上状态：闭包</h5><p><strong>闭包</strong>（closure）是编程语言领域里的一个专有名词。简单来说，闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为函数增加状态的另一种方式。</p><p>正常情况下，当 Python 完成一次函数执行后，本次使用的局部变量都会在调用结束后被回收，无法继续访问。但是，如果你使用下面这种“函数套函数”的方式，在外层函数执行结束后，返回内嵌函数，后者就可以继续访问前者的局部变量，形成了一个“闭包”结构。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_counter</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># nonlocal 用来标注变量来自上层作用域，如不标明，内层函数将无法直接修改外层函数变量</span></span><br><span class="line">        <span class="keyword">nonlocal</span> value</span><br><span class="line">        </span><br><span class="line">        value += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> _counter</span><br></pre></td></tr></table></figure><p>调用 counter 返回的结果函数，可以继续访问本该被释放的 value 的变量的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 创建一个与 c 无关的新闭包对象 c2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c2 = counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c2()</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>相比全局变量，使用闭包最大的特点就是封装性要好很多。在闭包代码里，索引变量 called_cnt 完全处于闭包内部，不会污染全局命名空间，而且不同闭包对象之间也不会相互影响。</p><p>总而言之，闭包是一种非常有用的工具，非常适合用来实现简单的有状态函数。</p><p>不过，除了闭包之外，还有一个天生就适合用来实现“状态”的工具：类。</p><h5 id="给函数加上状态：类"><a href="#给函数加上状态：类" class="headerlink" title="给函数加上状态：类"></a>给函数加上状态：类</h5><p>在一个类中，状态和行为可以被很好地封装在一起，因此它天生适合用来实现有状态对象。</p><p>不过严格来说，这个方案最终依赖的 CycleMosaic().generate，并非一个有状态的<strong>函数</strong>，而是一个有状态的<strong>实例方法</strong>。但无论是函数还是实例方法，它们都是“可调用对象”的一种，都可以作为 re.sub() 函数的 repl 参数使用。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>以上出现了三种实现有状态函数的方式，这三种方式各有优缺点，总结：</p><p>基于全局变量：</p><ul><li>学习成本最低，最容易理解；</li><li>会增加模块级的全局状态，封装性和可维护性最差。</li></ul><p>基于函数闭包：</p><ul><li>学习成本适中，可读性较好；</li><li>适合用来实现变量较少，较简单的有状态函数。</li></ul><p>创建类来封装状态：</p><ul><li>学习成本较高；</li><li>当变量较多、行为较复杂时，类代码比闭包代码更易读，也更容易维护。</li></ul><p>在日常编码中，如果你需要实现有状态的函数，应该尽量避免使用全局变量，闭包或类才是更好的选择。</p><h3 id="编程建议-5"><a href="#编程建议-5" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="别写太复杂的函数"><a href="#别写太复杂的函数" class="headerlink" title="别写太复杂的函数"></a>别写太复杂的函数</h4><h5 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h5><p>从作者自身的经验来看，对于 Python 这种强表现力的语言来说，65 行已经非常值得警惕了。假如超过 65 行，很大概率代表函数已经过于复杂，承担了太多职责，请考虑将它拆分成多个小而简单的子函数（类）吧。</p><h5 id="圈复杂度"><a href="#圈复杂度" class="headerlink" title="圈复杂度"></a>圈复杂度</h5><p>“圈复杂度”是由 Thomas J.McCabe 在 1976 年提出的用于评估函数复杂度的指标。它的值是一个正整数，代表函数内线性独立路径的数量。圈复杂度的值越大，表示程序可能的执行路径就越多，逻辑越复杂。</p><p>如果某个函数的圈复杂度超过 10， 就代表它已经太复杂了，代码编写者应该想办法简化。</p><p>你可以通过 radon 工具计算一个函数的圈复杂度。radon 基于 Python 编写，使用 pip install radon 即可完成安装。</p><h4 id="一个函数只包含一层抽象"><a href="#一个函数只包含一层抽象" class="headerlink" title="一个函数只包含一层抽象"></a>一个函数只包含一层抽象</h4><h5 id="什么是抽象"><a href="#什么是抽象" class="headerlink" title="什么是抽象"></a>什么是抽象</h5><h5 id="抽象与软件开发"><a href="#抽象与软件开发" class="headerlink" title="抽象与软件开发"></a>抽象与软件开发</h5><p>在计算机科学领域，人们广泛使用了抽象能力，并围绕抽象发明了许多概念和理论，而分层思想就是其中最重要的概念之一。</p><p>什么是分层？就是在设计一个复杂系统时，按照问题抽象程度的高低，将系统划分为不同的<strong>抽象层</strong>（abstraction layer）。低层的抽象层里包含较多的实现细节。随着层级变高，细节越来越少，越接近我们想要解决的实际问题。</p><p>假如一个函数内同时包含了多个抽象级别的内容，就会引发一系列的问题。</p><h5 id="脚本案例：调用-API-查找歌手的第一张专辑"><a href="#脚本案例：调用-API-查找歌手的第一张专辑" class="headerlink" title="脚本案例：调用 API 查找歌手的第一张专辑"></a>脚本案例：调用 API 查找歌手的第一张专辑</h5><h5 id="脚本抽象级别分析"><a href="#脚本抽象级别分析" class="headerlink" title="脚本抽象级别分析"></a>脚本抽象级别分析</h5><p>评价函数好坏还有一个重要指标：函数内的代码是否在同一个抽象层内。</p><p>抽象级别上的混乱，会导致下面两个问题：</p><ul><li>函数代码的说明性不够；</li><li>函数的可复用性差。</li></ul><h5 id="基于抽象层重构代码"><a href="#基于抽象层重构代码" class="headerlink" title="基于抽象层重构代码"></a>基于抽象层重构代码</h5><p>在设计函数时，请时常记得检查函数内代码是否在同一个抽象层级别，如果不是，那就需要把函数拆成更多小函数。只有保证抽象级别一致，代码才更易读、更易维护。</p><h4 id="优先使用列表推导式"><a href="#优先使用列表推导式" class="headerlink" title="优先使用列表推导式"></a>优先使用列表推导式</h4><p>函数式编程是一种编程风格，它最大的特征，就是通过组合大量没有副作用的“纯函数”来实现复杂的功能。如果你想在 Python 中实践函数式编程，最常用的几个工具如下所示。</p><ol><li>map(func, iterable)：遍历并执行 func 获得结果，迭代返回新结果。</li><li>filter(func, iterable)：遍历并使用 func 测试成员，仅当结果为真时返回。</li><li>lambda：定义一个一次性使用的匿名函数。</li></ol><p>例，假如你想获取所有处于活跃状态的用户积分，代码可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points = list(map(query_points, filter(<span class="keyword">lambda</span> user: user.is_active(), users)))</span><br></pre></td></tr></table></figure><p>但比起上面这种 map 套 filter 的写法，我们其实可以完全可以使用列表推导式来搞定这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points = [query_points(user) <span class="keyword">for</span> user <span class="keyword">in</span> users <span class="keyword">if</span> user.is_active()]</span><br></pre></td></tr></table></figure><p>在大多数情况下，相比函数式编程，使用列表推导式的代码通常更短，而且描述性更强。所以，当列表推导式可以满足需求时，请优先使用它吧。</p><h4 id="你没有那么需要-lambda"><a href="#你没有那么需要-lambda" class="headerlink" title="你没有那么需要 lambda"></a>你没有那么需要 lambda</h4><p>匿名函数最常见的用途就是作为 sorted() 函数的排序参数使用。</p><p>对于一些进行简单操作的匿名函数，我们其实完全可以用 operator 模块里的函数来替代它。比如使用 operator.itemgetter()、operator.add()、operator.attrgetter() 等。</p><p>总之，Python 中的 lambda 函数只是一颗简单的语法糖。它的许多使用场景，要么本身就不存在，要不更适合用 operator 模块来满足。lambda 并非无可替代。请记住，没什么特殊功能是 lambda 能做到而普通函数做不到的。</p><h4 id="了解递归的局限性"><a href="#了解递归的局限性" class="headerlink" title="了解递归的局限性"></a>了解递归的局限性</h4><p>在编程语言领域，为了避免递归导致调用栈过深，占用过多资源，不少编程语言使用一种被称为<strong>尾调用优化</strong>（tail call optimization）的技术。</p><p>但 Python 没有这种技术。因此在使用递归时，你必须对函数的输入数据规模时刻保持警惕，确保它所触发的递归深度，一定远远低于 sys.getrecursionlimit() 的最大限制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然函数可以消除重复代码，但绝不能只把它看成一种复用代码的工具。函数最重要的价值其实是创建抽象，而提供复用价值甚至可以算是抽象所带来的一种“副作用”。</p><h2 id="第-8-章-装饰器"><a href="#第-8-章-装饰器" class="headerlink" title="第 8 章 装饰器"></a>第 8 章 装饰器</h2><p>ORM(object-relational mapping，对象关系映射)：一种把数据库中的数据自动映射为程序内对象的技术。</p><p>Click：基于装饰器的命令行工具集。</p><p>不过，虽然 Python 里的装饰器（decorator）很有用，但它本身并不复杂，只是 Python 语言的一颗小小的语法糖。如你所知，这样的装饰器应用代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>完全等同于下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">function = cache(function)</span><br></pre></td></tr></table></figure><p>装饰器并不提供任何独特的功能，它所做的，只是让我们可以在函数定义语句的上方，直接添加用来修改函数行为的装饰器函数。假如没有装饰器，我们也可以在完成函数定义后，手动做一次包装和重新定义。</p><h3 id="基础知识-7"><a href="#基础知识-7" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="装饰器基础"><a href="#装饰器基础" class="headerlink" title="装饰器基础"></a>装饰器基础</h4><p><strong>装饰器</strong>是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的闭包原理实现的。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">""" 装饰器：打印函数耗时 """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        st = time.perf_counter()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'time cost: &#123;&#125; second'</span>.format(time.perf_counter() - st))</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure><p>在写装饰器时，作者一般把 decorated 叫做“包装函数”。这些包装函数通常接收任意数目的可变参数（<em>args, *</em>kwargs），主要通过调用原始函数 func 来完成工作。在包装函数内部，常会增加一些额外步骤，比如打印信息、修改参数等。</p><p>当其他函数应用了 timer装饰器后，包装函数 decorated 会作为装饰器的返回值，完全替换被装饰的原始函数func。</p><p>假如你想实现一个接收参数的装饰器，代码会更复杂一些。在应用有参装饰器时，一共要做两次函数调用，所以装饰器总共得包含三层嵌套函数。正因为如此，有参数装饰器的代码一直都难写、难读。但不要紧，在后面章节，作者会介绍如何用类来实现有参数装饰器，减少代码的嵌套层数。</p><h4 id="使用-functools-wraps-修饰包装函数"><a href="#使用-functools-wraps-修饰包装函数" class="headerlink" title="使用 functools.wraps() 修饰包装函数"></a>使用 functools.wraps() 修饰包装函数</h4><p>在编写装饰器时，切记使用 @functools.wraps() 来修饰包装函数。</p><h4 id="实现可选参数装饰器"><a href="#实现可选参数装饰器" class="headerlink" title="实现可选参数装饰器"></a>实现可选参数装饰器</h4><p>当你实现了一个接收参数的装饰器后，即便所有参数都是有默认值的可选参数，你也必须在使用装饰器时加上括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用装饰器时提供参数</span></span><br><span class="line"><span class="meta">@delayed_start(duration=2)</span></span><br><span class="line"><span class="comment"># 不提供参数，也需要使用括号调用装饰器</span></span><br><span class="line"><span class="meta">@delayed_start()</span></span><br></pre></td></tr></table></figure><p>如果想要省去那对括号，利用仅限关键字参数，可以很方便做到这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把所有参数都变成提供了默认值的可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delayed_start</span><span class="params">(func=None, *, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">""" 装饰器：在执行被装饰函数时，等待一段时间</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    :param duration: 需要等待的秒数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(_func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">f'Wait for <span class="subst">&#123;duration&#125;</span> second second before starting...'</span>)</span><br><span class="line">            time.sleep(duration)</span><br><span class="line">            <span class="keyword">return</span> _func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 当 func 为 None 时，代表使用方提供了关键字参数，比如 @delayed_start(duration=2)，</span></span><br><span class="line">        <span class="comment"># 此时返回接收单个函数参数的内层子装饰器 decorator</span></span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 当位置参数 func 不为 None 时，代表使用方没提供关键字参数，直接用了无括号的@delayed_start 调用方式，</span></span><br><span class="line">        <span class="comment"># 此时返回内层包装函数 wrapper</span></span><br><span class="line">        <span class="keyword">return</span> decorator(func)</span><br></pre></td></tr></table></figure><p>这样定义装饰器以后，我们可以通过多种方式来使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 不提供任何参数</span></span><br><span class="line"><span class="meta">@delayed_start</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 提供可选的关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 提供括号调用，但不提供任何参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span> ...</span><br></pre></td></tr></table></figure><p>把参数变为可选能有效降低使用者的心智负担，让装饰器变得更易用。标准库 dataclasses 模块里的 @dataclass 装饰器就使用了这个小技巧。</p><p>关于装饰器，还可参考<a href="https://www.geeksforgeeks.org/decorators-in-python/" target="_blank" rel="noopener">网络</a>。</p><h4 id="用类来实现装饰器（函数替换）"><a href="#用类来实现装饰器（函数替换）" class="headerlink" title="用类来实现装饰器（函数替换）"></a>用类来实现装饰器（函数替换）</h4><p>事实上，某个对象是否能通过装饰器（@decorator）的形式使用只有一条判断标准，那就是 decorator 是不是一个可调用的对象。</p><p>函数自然是可调用对象，除此之外，类同样也是可调用对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 使用 callable() 内置函数可以判断某个对象是否可调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(Foo)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果一个类实现了 __call__ 魔法方法，那么它的实例也会变成可调用对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">f'Hello, <span class="subst">&#123;name&#125;</span>'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(foo)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="string">'World'</span>)</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure><p>__call__ 魔法方法是用来实现可调用对象的关键方法。</p><p>调用类实例时，可以像调用普通函数一样提供额外参数。</p><p>基于类的这些特点，我们完全可以用它来实现装饰器。</p><p>如果按装饰器用于替换原函数的对象类型来分类，类实现的装饰器可分为两种，一种是“函数替换”，另一种是“实例替换”。</p><p>函数替换装饰器虽然是基于类实现的，但用来替换原函数的对象仍然是个普通的包装函数。这种技术最适合用来实现接收参数的装饰器。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timer</span>:</span></span><br><span class="line">    <span class="string">""" 装饰器：打印函数耗时</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param print_args： 是否打印方法名和参数，默认为 False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, print_args)</span>:</span></span><br><span class="line">        self.print_args = print_args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            st = time.perf_counter()</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> self.print_args:</span><br><span class="line">                print(<span class="string">f'"<span class="subst">&#123;func.__name__&#125;</span>", args: <span class="subst">&#123;args&#125;</span>, kwargs: <span class="subst">&#123;kwargs&#125;</span>'</span>)</span><br><span class="line">            print(<span class="string">'time cost: &#123;&#125; second'</span>.format(time.perf_counter() - st))</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><p>通过类实现的装饰器，其实就是把原本的两次函数调用替换成了类和类实例的调用。</p><ol><li>第一次调用：_deco = timer(print_args=True) 实际上是在初始化一个 timer 实例。</li><li>第二次调用：func = _deco(func) 是在调用 timer 实例，触发 __call__ 方法。</li></ol><p>虽然“函数替换”装饰器的代码更简单，但它和普通装饰器没有本质区别。下面作者介绍了另一种更为强大的装饰器——用实例来替换原函数的“实例替换”装饰器。</p><h4 id="用类来实现装饰器（实例替换）"><a href="#用类来实现装饰器（实例替换）" class="headerlink" title="用类来实现装饰器（实例替换）"></a>用类来实现装饰器（实例替换）</h4><p>和“函数替换”装饰器不一样，“实例替换”装饰器最终会用一个类实例来替换原函数。通过组合不同的工具，它既能实现无参数装饰器，也能实现有参数装饰器。</p><h5 id="实现无参数装饰器"><a href="#实现无参数装饰器" class="headerlink" title="实现无参数装饰器"></a>实现无参数装饰器</h5><p>用类来实现装饰器时，被装饰的函数 func 会作为唯一的初始化参数传递到类的实例化方法 __init__ 中。同时，类的实例化结果——<strong>类实例</strong>（class instance），会作为包装对象替换原始函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeplayedStart</span>:</span></span><br><span class="line">    <span class="string">""" 在执行被装饰函数前，等待 1 秒钟 """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="comment"># update_wrapper 与前面的 wraps 一样，都是把被包装函数的元数据更新到包装者（在这里是 DelayedStart 实例）上</span></span><br><span class="line">        update_wrapper(self, func)</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 通过实现 __call__ 方法，让 DelayedStart 实例变得可调用，以此模拟函数的可调用行为</span></span><br><span class="line">        print(<span class="string">f'Wait for 1 second before starting...'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eager_call</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 为装饰器类定义额外方法，提供更多样化的接口</span></span><br><span class="line">        print(<span class="string">'Call without delay'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@DelayedStart</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Hello World.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello</span><br><span class="line">&lt;__main__.DelayedStart object at <span class="number">0x100b71130</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(hello)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">DelayedStart</span>'&gt;</span></span><br><span class="line"><span class="class"># 被装饰的 <span class="title">hello</span> 函数已经变成了装饰器类 <span class="title">DelayedStart</span> 的实例，但是因为 <span class="title">update_wrapper</span> 的作用，这个实例仍然保留了被装饰函数的元数据</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">hello</span>.<span class="title">__name__</span></span></span><br><span class="line"><span class="class">'<span class="title">hello</span>'</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 此时触发的是装饰器类实例的 <span class="title">__call__</span> 方法</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="class"><span class="title">Wait</span> <span class="title">for</span> 1 <span class="title">second</span> <span class="title">before</span> <span class="title">starting</span>...</span></span><br><span class="line">Hello, World.</span><br><span class="line"><span class="comment"># 使用额外的 eager_call 接口调用函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello.eager_call()</span><br><span class="line">Call without delay</span><br><span class="line">Hello, World.</span><br></pre></td></tr></table></figure><h5 id="实现有参数装饰器"><a href="#实现有参数装饰器" class="headerlink" title="实现有参数装饰器"></a>实现有参数装饰器</h5><p>同普通装饰器一样，“实例替换”装饰器也可以支持参数。为此我们需要先修改类的实例化方法，增加额外的参数，再定义一个新函数，有它来负责基于类创建新的可调用对象，这个新函数同时也是会被实际使用的装饰器。例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayedStart</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, *, duration=<span class="number">1</span>)</span>:</span></span><br><span class="line">        update_wrapper(self, func)</span><br><span class="line">        self.func = func</span><br><span class="line">        self.duration = duration</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f'Wait for <span class="subst">&#123;self.duration&#125;</span> second before starting...'</span>)</span><br><span class="line">        time.sleep(self.duration)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eager_call</span><span class="params">(self, *args, **kwargs)</span>:</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 partial 构建一个新的可调用对象，这个对象接收的唯一参数是待装饰函数 func，因此可以用作装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delayed_start</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> functools.partial(DelayedStart, **kwargs)</span><br></pre></td></tr></table></figure><p>使用样例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@delayed_start(duration=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello, World.'</span>)</span><br></pre></td></tr></table></figure><p>相比传统做法，用类来实现装饰器（实例替换）的主要优势在于，你可以更方便地管理装饰器的内部状态，同时也可以更自然地为被装饰对象追加额外的方法和属性。</p><h4 id="使用-wrapt-模块助力装饰器编写"><a href="#使用-wrapt-模块助力装饰器编写" class="headerlink" title="使用 wrapt 模块助力装饰器编写"></a>使用 wrapt 模块助力装饰器编写</h4><p>使用 wrapt 模块编写的装饰器，除了解决了类方法兼容的问题以外，代码嵌套层级也比普通装饰器少，变得更扁平、更易读。</p><h3 id="编程建议-6"><a href="#编程建议-6" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="了解装饰器的本质优势"><a href="#了解装饰器的本质优势" class="headerlink" title="了解装饰器的本质优势"></a>了解装饰器的本质优势</h4><p>装饰器带来的改变，主要在于把修改函数的调用提前到了函数定义外，而这一点儿位置上的小变化，重塑了读者理解代码的整个过程。</p><p>所以，装饰器的优势并不在于它提供了动态修改函数的能力，而在于它把影响函数的装饰行为移到了函数头部，降低了代码的阅读与理解成本。</p><h4 id="使用类装饰器替代元类"><a href="#使用类装饰器替代元类" class="headerlink" title="使用类装饰器替代元类"></a>使用类装饰器替代元类</h4><p>Python 中的元类（metaclass）是一种特殊的类。就像类可以控制实例的创建过程一样，元类可以控制类的创建过程。</p><p>相比元类，使用类装饰器的代码要容易理解得多。</p><p>除了文中提到的注册功能以外，你还可以用类装饰器完成许多实用的事情，比如实现单例设计模式、自动为类追加方法，等等。</p><p>虽然类装饰器并不能覆盖元类的所有功能，但在许多场景下，类装饰器可能比元类更合适，因为它不光写起来容易，理解起来也更简单。像广为人知的标准库模块 dataclass 里的 @dataclass 就选择了类装饰器，而不是元类。</p><h4 id="别弄混装饰器和装饰器模式"><a href="#别弄混装饰器和装饰器模式" class="headerlink" title="别弄混装饰器和装饰器模式"></a>别弄混装饰器和装饰器模式</h4><p>装饰器模式属于面向对象领域。实现装饰器模式，需要具备以下关键要素：</p><ul><li>设计一个统一的接口；</li><li>编写多个符合该接口的装饰器类，每个类只实现一个简单的功能；</li><li>通过组合的方式嵌套使用这些装饰器类；</li><li>通过类和类之间的层层包装来实现复杂的功能。</li></ul><h4 id="浅装饰器，深实现"><a href="#浅装饰器，深实现" class="headerlink" title="浅装饰器，深实现"></a>浅装饰器，深实现</h4><p>归根到底，装饰器只是一类特殊的 API，一种提供服务的方式。比起把所有核心逻辑都放在装饰器内，不如让装饰器里只有一层浅浅的包装层，而把更多的实现细节都放在其他函数或类中。</p><p>这样做之后，假如你未来需要为模块增加装饰器以外的其他 API，比如上下文管理器，就会发现自己之前写的大部分核心代码仍然可以复用，因为它们并没有和装饰器耦合。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h2 id="第-9-章-面向对象编程"><a href="#第-9-章-面向对象编程" class="headerlink" title="第 9 章 面向对象编程"></a>第 9 章 面向对象编程</h2><p>Python 语言在整体设计上深受面向对象思想的影响。你经常可以听到“在 Python 里，万物皆对象”这句话。这并不夸张，在 Python 中，最基础的浮点数也是一个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">1.3</span></span><br><span class="line"><span class="comment"># 调用浮点数对象的 is_integer() 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.is_integer()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="基础知识-8"><a href="#基础知识-8" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="类常用知识"><a href="#类常用知识" class="headerlink" title="类常用知识"></a>类常用知识</h4><h5 id="私有属性是“君子协定”"><a href="#私有属性是“君子协定”" class="headerlink" title="私有属性是“君子协定”"></a>私有属性是“君子协定”</h5><p>当你使用 __{var} 的方式定义一个私有属性时，Python 解释器只是重新给了它一个包含当前类名的别名 _{class}__{var}，因此你仍然可以在外部用这个别名来访问和修改它。</p><p>因为私有属性依赖这套别名机制工作，所以私有属性的最大用途，其实是在父类中定义一个不容易被子类重写的受保护属性。</p><p>而在日常编程中，我们极少使用双下划线来标示一个私有属性。如果你认为某个属性是私有的，直接给它加上单下划线 _ 前缀就够了。而“标准”的双下划线前缀，反而可能会在子类想要重写父类私有属性时带来不必要的麻烦。</p><h5 id="实例内容都在字典里"><a href="#实例内容都在字典里" class="headerlink" title="实例内容都在字典里"></a>实例内容都在字典里</h5><p>Python 语言内部大量使用了<strong>字典</strong>类型，比如一个类实例的所有成员，其实都保存在了一个名为 __dict__ 的字典属性中。</p><p>而且，不光实例有这个字典，类其实也有这个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'Hi, my name is <span class="subst">&#123;self.name&#125;</span>, I\'m <span class="subst">&#123;self.age&#125;</span>.'</span>)</span><br></pre></td></tr></table></figure><p>查看 __dict__：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">'raymond'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 实例的 __dict__ 里，保存着当前实例的所有数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.__dict__</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'raymond'</span>, <span class="string">'age'</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="comment"># 类的 __dict__ 里，保存着类的文档、方法等所有数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.__dict__</span><br><span class="line">mappingproxy(&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__init__'</span>: &lt;function Person.__init__ at <span class="number">0x000001E830EA70D0</span>&gt;, <span class="string">'say'</span>: &lt;function Person.say at <span class="number">0x000001E830EA7160</span>&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'Person'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'Person'</span> objects&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>&#125;)</span><br></pre></td></tr></table></figure><p>在绝大多数情况下，__dict__ 字典对于我们来说是实现细节，并不需要手动操作它。但在有些场景下，使用 __dict__ 可以帮助我们巧妙地完成一些特定任务。</p><p>比如，你有一份包含 Person 类数据的字典 {‘name’: …, ‘age’: …}。现在你想把这份字典里的数据直接赋值到某个 Person 实例上。最简单的做法是通过遍历字典来设置属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'name'</span>: <span class="string">'andrew'</span>, <span class="string">'age'</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span>    setattr(p, key, value)</span><br></pre></td></tr></table></figure><p>但除此之外，其实也可以直接修改实例的 __dict__ 属性来快速达到目的：p.__dict__.update(d)。</p><p>不过需要注意的是，修改实例的 __dict__ 与循环调用 setattr() 方法这两个操作并不完全等价，因为类的属性设置行为可以通过定义 __setattr__ 魔法方法修改。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'age'</span> <span class="keyword">and</span> value &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f'Invalid age value: <span class="subst">&#123;value&#125;</span>'</span>)</span><br><span class="line">        super().__setattr__(name, value)</span><br></pre></td></tr></table></figure><p>在上面的代码里，Person 类增加了 __setattr__ 方法，实现了对 age 值的校验逻辑。执行效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">'raymond'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.age = <span class="number">-3</span></span><br><span class="line">ValueError: Invalid age value: <span class="number">-3</span></span><br></pre></td></tr></table></figure><p>虽然普通的属性赋值会被 __setattr__ 限制，但如果你直接操作实例的 __dict__ 字典，就可以无视这个限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.__dict__[<span class="string">'age'</span>] = <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.say()</span><br><span class="line">Hi, my name <span class="keyword">is</span> raymond, I<span class="string">'m -3.</span></span><br></pre></td></tr></table></figure><p>在某些特殊场景下，合理利用 __dict__ 属性的这个特性，可以帮助你完成常规做法难以做到的一些事情。</p><h4 id="内置类方法装饰器"><a href="#内置类方法装饰器" class="headerlink" title="内置类方法装饰器"></a>内置类方法装饰器</h4><h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><p>当你用 def 在类里定义一个函数时，这个函数通常称作方法。调用方法需要先创建一个类实例。</p><p>虽然普通方法无法通过类来调用，但你可以用 @classmethod 装饰器定义一种特殊的方法：<strong>类方法</strong>（class method），它属于类但是无须实例化也可调用。</p><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'Hi, I\'m a <span class="subst">&#123;self.color&#125;</span> duck!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="comment"># 普通方法接收类实例（self）作为参数，但类方法的第一个参数就是类本身，通常使用名字 cls</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_random</span><span class="params">(cls)</span>:</span></span><br><span class="line">        color = random.choice([<span class="string">'yellow'</span>, <span class="string">'white'</span>, <span class="string">'gray'</span>])</span><br><span class="line">        <span class="keyword">return</span> cls(color = color)</span><br></pre></td></tr></table></figure><p>调用效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Duck.create_random()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.quack()</span><br><span class="line">Hi, I<span class="string">'m a yellow duck!</span></span><br><span class="line"><span class="string"># 虽然类方法通常是用类来调用，但你也可以通过实例来调用类方法，效果一样</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; d.create_random()</span></span><br><span class="line"><span class="string">&lt;__main__.Duck object at 0x10f8f2f40&gt;</span></span><br></pre></td></tr></table></figure><p>作为一种特殊方法，类方法最常见的使用场景，就是像上面一样定义工厂方法来生成新实例。类方法的主角是类型本身，当你发现某个行为不属于实例，而是属于整个类型时，可以考虑使用类方法。</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>如果你发现某个方法不需要使用当前实例里的任何内容，那可以使用 @staticmethod 来定义一个静态方法。</p><p>静态方法不接收当前实例作为第一个位置参数。</p><p>选择静态方法还是普通函数，可以从以下几点来考虑：</p><ul><li>如果静态方法特别通用，与类关系不大，那么把它改成普通函数可能会更好；</li><li>如果静态方法与类关系密切，那么用静态方法更好；</li><li>相比函数，静态方法有一些先天优势，比如能被子类继承和重写等。</li></ul><h5 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h5><p>@property 装饰器模糊了属性和方法间的界限，使用它，你可以把方法通过属性的方式暴露出来。</p><p>例，把方法变成一个虚拟属性，然后像使用普通属性一样使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilePath</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basename</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.path.rsplit(os.sep, <span class="number">1</span>)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>调用效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = FilePath(<span class="string">'/tmp/foo.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.basename</span><br><span class="line"><span class="string">'foo.py'</span></span><br></pre></td></tr></table></figure><p>@property 除了可以定义属性的读取逻辑外，还支持自定义写入和删除逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilePath</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basename</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.path.rsplit(os.sep, <span class="number">1</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 经过 @property 的装饰之后，basename 已经从一个普通方法变成了 property 对象，因此这里可以使用 basename.setter</span></span><br><span class="line"><span class="meta">    @basename.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basename</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 定义 setter 方法，该方法会在对属性赋值时被调用</span></span><br><span class="line">        new_path = self.path.rsplit(os.sep, <span class="number">1</span>)[:<span class="number">-1</span>] + [name]</span><br><span class="line">        self.path = os.sep.join(new_path)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @basename.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">basename</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 定义 deleter 方法，该方法会在删除属性时被调用</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">'Can not delete basename!'</span>)</span><br></pre></td></tr></table></figure><p>调用效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = FilePath(<span class="string">'/tmp/foo.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.basename = <span class="string">'bar.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.path</span><br><span class="line"><span class="string">'/tmp/bar.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> p.basename</span><br><span class="line">RuntimeError: Can <span class="keyword">not</span> delete basename!</span><br></pre></td></tr></table></figure><p>@property 是个非常有用的装饰器，它让我们可以基于方法定义类属性，精确地控制属性的读取、赋值和删除行为，灵活地实现动态属性等功能。</p><p>除了 @property 以外，<strong>描述符</strong>也能做到同样的事情，并且功能更多、更强大。</p><p>人们在读取属性时，总是期望能迅速拿到结果，调用方法则不应——快点儿慢点儿都无所谓。让自己设计的接口符合他人的使用预期，也是写代码时很重要的一环。</p><h4 id="鸭子类型及其局限性"><a href="#鸭子类型及其局限性" class="headerlink" title="鸭子类型及其局限性"></a>鸭子类型及其局限性</h4><p>“Python 是一门鸭子类型的编程语言”。</p><p>虽然这个定义被广泛接受，但是和“静态类型”“动态类型”这些名词不一样，“鸭子类型”（duck-typing）不是什么真正的类型系统，而只是一种特殊的<strong>编程风格</strong>。</p><p>在鸭子类型编程风格下，如果想操作某个对象，你不会去判断它是否属于某种类型，而会直接判断它是不是有你需要的方法（或属性）。或者更激进一点，你甚至会直接尝试调用需要的方法，假如失败了，那就让它报错好了。</p><blockquote><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以称为鸭子。<br><em>——来自“鸭子类型”的维基百科词条</em></p></blockquote><p>也就是说，虽然 Python 提供了检查类型的函数：isinstance()，但是鸭子类型并不推荐你使用它。你想调用 items 对象的 append() 方法？别拿 isinstance(items, list) 判断 items 究竟是不是列表，想调就直接调吧！</p><p>在纯粹的鸭子类型编码风格下，不应该出现任何的 isinstance 类型判断语句。</p><p>鸭子类型确实有许多优点。首先，鸭子类型不推荐做类型检查，因此编码者可以省去大量与之相关的繁琐工作。其次，鸭子类型只关注对象是否能完成某件事，而不对类型做强制要求，这大大提升了代码的灵活性。</p><p>鸭子类型的局限性：</p><ol><li>缺乏标准。在编写鸭子类型代码时，虽然我们不需要做严格的类型校验，但是仍然需要频繁判断对象是否支持某个行为，而这方面没有统一的标准。</li><li>过于隐式。在鸭子类型编程风格下，对象的真实类型变得不再重要，取而代之的是对象所提供的接口（或者叫协议）变得非常重要。但问题是，鸭子类型里的所有接口和协议都是隐式的，它们全藏在代码和函数的注释中。</li></ol><p>在鸭子类型里，所有的接口和协议零碎地分布在代码的各个角落，最终虚拟地活在编码者地大脑中。</p><p>幸运的是，除了鸭子类型以外，Python 还为类型系统提供了许多有效的补充，比如类型注解与静态检查（mypy）、抽象类（abstract class）等。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>自从抽象类出现以后，isinstance() 函数的地位发生了一些微妙的变化。</p><h5 id="isinstance-函数"><a href="#isinstance-函数" class="headerlink" title="isinstance() 函数"></a>isinstance() 函数</h5><p>使用 isinstance() 函数，我们可以严格校验对象是否属于某个类型。但问题是：鸭子类型只关心行为，不关心类型，所以isinstance() 函数天生和鸭子类型的理念相背。不过，在 Python 2.6 版本推出了抽象类以后，事情出现了一些转折。</p><h5 id="校验对象是否是-Iterable-类型"><a href="#校验对象是否是-Iterable-类型" class="headerlink" title="校验对象是否是 Iterable 类型"></a>校验对象是否是 Iterable 类型</h5><p>虽然 ThreeFactory 没有继承 Iterable 类，但当我们用 isinstance() 检查它是否属于 Iterable 类型时，结果却是 True，这正是受了抽象类的特殊子类化机制的影响。</p><h5 id="抽象类的子类化机制"><a href="#抽象类的子类化机制" class="headerlink" title="抽象类的子类化机制"></a>抽象类的子类化机制</h5><p>在 Python 中，最常见的子类化方式是通过继承基类来创建子类。但抽象类作为一种特殊的基类，为我们提供了另一种更灵活的子类化机制。</p><p>例，以下为抽象类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要定义一个抽象类，你需要继承 ABC 类或使用 abc.ABCMeta 元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">""" 校验器抽象类 """</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="string">""" 任何提供了 validate 方法的类，都被当做 Validator 的子类 """</span></span><br><span class="line">        <span class="keyword">if</span> any(<span class="string">"validate"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):</span><br><span class="line">            <span class="comment"># C.__mro__ 代表 C 的类派生路线上的所有类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>上面代码的重点是 __subclasshook__ 类方法。__subclasshook__ 是抽象类的一个特殊方法，当你使用 isinstance 检查对象是否属于某个抽象类时，如果后者定义了这个方法，那么该方法就会被触发，然后：</p><ul><li>实例所属类型会作为参数传入该方法（上面代码里的 C 参数）；</li><li>如果方法返回了布尔值，该值表示实例类型是否属于抽象类的子类；</li><li>如果方法返回 NotImplemented，本次调用会被忽略，继续进行正常的子类判断逻辑。</li></ul><p>在上面的 Validator 类中，__subclasshook__ 方法的逻辑是：所有实现了 validate 方法的类都是我的子类。</p><p>通过 __subclasshook__ 类方法，我们可以定制抽象类的子类判断逻辑。这种子类化形式只关心结构，不关心真实继承关系，所以常被称为“结构化子类”。</p><p>Iterable 抽象类对子类只有一个要求，实现了 __iter__ 方法即可。</p><p>除了通过 __subclasshook__ 类方法来定义动态的子类检查逻辑外，你还可以为抽象类手动注册新的子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Foo, Validator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Validator.register(Foo)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Foo, Validator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Foo(), Validator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>总结一下，抽象类通过 __subclasshook__ 钩子和 .register() 方法，实现了一种比继承更灵活、更松散的子类化机制，并以此改变了 isinstance() 的行为。</p><p>有了抽象类以后，我们便可以使用 isinstance(obj, type) 来进行鸭子类型编码风格的类型校验了。只要待匹配类型 type 是抽象类，类型检查就符合鸭子类型编程风格——只校验行为，不校验类型。</p><h5 id="抽象类的其他功能"><a href="#抽象类的其他功能" class="headerlink" title="抽象类的其他功能"></a>抽象类的其他功能</h5><p>除了更灵活的子类化机制外，抽象类还提供了一些其他功能。比如，利用 abc 模块的 @abstractmethod 装饰器，你可以把某个方法标记为抽象方法。假如抽象类的子类在继承时，没有重写所有抽象方法，那么它就无法被正常实例化。</p><h4 id="多重继承与-MRO"><a href="#多重继承与-MRO" class="headerlink" title="多重继承与 MRO"></a>多重继承与 MRO</h4><p>在解决多重继承的方法优先级问题时，Python 使用了一种名为 MRO（method resolution order）的算法。该算法会遍历类的所有基类，并将它们按优先级从高到低排好序。</p><p>调用类的 mro() 方法，你可以看到按 MRO 算法排好序的基类列表：</p><p>MRO 与 super()</p><p>基于 MRO 算法的基类优先级列表，不光定义了类方法的找寻顺序，还影响了另一个常见的内置函数：super()。</p><p>super() 使用的其实不是当前类的父类，而是它在 MRO 链条里的上一个类。</p><p>当你在方法中调用 super() 时，其实无法确定它会定位到哪个类。这是因为你永远不知道使用类的人，会把它加入什么样的 MRO 链条里。</p><p>大多数情况下，你需要的并不是多重继承，而也许只是一个更准确的抽象模型，在该模型下，最普通的继承关系就能完美解决问题。</p><h4 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h4><h5 id="Mixin-模式"><a href="#Mixin-模式" class="headerlink" title="Mixin 模式"></a>Mixin 模式</h5><p>Mixin 是一种把额外功能“混入”某个类的技术。有些编程语言（比如Ruby）为 Mixin 模式提供了原生支持，而在 Python 中，我们可以用多重继承来实现 Mixin 模式。</p><p>大多数 Mixin 类不能单独使用，它们只有在被混入其他类时才能发挥最大作用。</p><p>假如你想使用 Mixin 模式，需要精心设计 Mixin 类的职责，让他们和普通类有所区分，这样才能让 Mixin 模式发挥最大的潜力。</p><h5 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h5><p>元类是 Python 中的一种特殊对象。元类控制着类的创建行为，就像普通类控制着实例的创建行为一样。</p><p>type 是 Python 中最基本的元类，利用 type，你根本不需要手动编写 class …: 代码来创建一个类——直接调用 type() 就行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Foo</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Foo</span><span class="params">()</span>.<span class="title">bar</span></span></span><br><span class="line"><span class="class">3</span></span><br></pre></td></tr></table></figure><p>虽然 type 是最基本的元类，但在实际编程中使用它的场景其实比较少。更多情况下，我们会创建一个继承 type 的新元类，然后在里面定制一些与创建类有关的行为。</p><h3 id="案例故事-7"><a href="#案例故事-7" class="headerlink" title="案例故事"></a>案例故事</h3><p>继承是一种类与类之间紧密的耦合关系。让子类继承父类，虽然看上去毫无成本地获取了父类地全部能力，但同时也意味着，从此以后父类地所有改动都可能影响子类。</p><p>同样是复用代码，组合产生地耦合关系比继承松散得多。如果组合可以达到复用目的，并且能够很好表达事物间地联系，那么常常是更好的选择。这也是人们常说“多用组合，少用继承”的原因。</p><p>但这并不代表我们应该完全弃用继承。继承所提供的强大复用能力，仍然是组合所无法替代的。许多设计模式（比如模板方法模式——template method pattern）都是依托继承来实现的。</p><h3 id="编程建议-7"><a href="#编程建议-7" class="headerlink" title="编程建议"></a>编程建议</h3><h4 id="使用-init-subclass-替代元类"><a href="#使用-init-subclass-替代元类" class="headerlink" title="使用 __init_subclass__ 替代元类"></a>使用 __init_subclass__ 替代元类</h4><p>__init_subclass__ 是类的一个特殊钩子方法，它的主要功能是在类派生出子类时，触发额外的操作。假如某个类实现了这个钩子方法，那么当其他类继承该类时，钩子方法就会被触发。</p><h4 id="在分支中寻找多态的应用时机"><a href="#在分支中寻找多态的应用时机" class="headerlink" title="在分支中寻找多态的应用时机"></a>在分支中寻找多态的应用时机</h4><p>多态（polymorphism）时面向对象编程的基本概念之一。它表示同一个方法调用，在运行时会因为对象类型的不同，产生不同效果。</p><p>比起把所有的分支和可能性，一股脑儿地塞进程序员的脑子里，多态思想驱使我们更积极地寻找有效的抽象，以此隔离各个模块，让他们之间通过规范的接口来通信。</p><p>找到使用多态的时机：</p><ul><li>有许多 if/else 判断，并且这些判断语句的条件都非常类似；</li><li>有许多针对类型的 isinstance() 判断逻辑。</li></ul><h4 id="有序组织你的类方法"><a href="#有序组织你的类方法" class="headerlink" title="有序组织你的类方法"></a>有序组织你的类方法</h4><p>在组织类方法时，我们应该关注使用者的诉求，把他们最想知道的内容放在前面，把他们不那么关心的内容放在后面。</p><p>公有方法应该放在类的前面，因为他们是其他模块调用类的入口，是类的门面，也是所有人最关心的内容。以 _ 开头的私有方法，大部分是类自身的实现细节，应该放在靠后的位置。</p><p>以 __ 开头的魔法方法比较特殊，我通常会按照方法的重要程度来决定他们的位置。比如一个迭代器类的 __iter__ 方法应该放在非常靠前的位置，因为它是构成类接口的重要方法。</p><p>最后一点，当你从上往下阅读类时，所有方法的抽象级别应该是不断降低的，就好像阅读一篇新闻一样，第一段是新闻的概要，之后才会描述细节。</p><h4 id="函数搭配，干活不累"><a href="#函数搭配，干活不累" class="headerlink" title="函数搭配，干活不累"></a>函数搭配，干活不累</h4><p>在写代码时，如果你在原有的面向对象代码上，撒上一点儿函数作为调味品，就会发生奇妙的化学反应。</p><h5 id="用函数降低-API-使用成本"><a href="#用函数降低-API-使用成本" class="headerlink" title="用函数降低 API 使用成本"></a>用函数降低 API 使用成本</h5><p>requests 的 API 都是普通函数，但内部完全是基于面向对象思想编写的。拿 requests.request() 函数来说，它的内部实现其实是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 来自 requests.api 模块</span></span><br><span class="line"><span class="keyword">from</span> request <span class="keyword">import</span> sessions</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(method, url, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># 实例化一个 Session 上下文对象，完成请求</span></span><br><span class="line">    <span class="keyword">with</span> sessions.Session() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">return</span> session.request(method=mothod, url=url, **kwargs)</span><br></pre></td></tr></table></figure><p>这有点像设计模式中的<strong>外观模式</strong>（facede pattern）。在该模式中，函数作为一种简化 API 的工具，封装了复杂的面向对象功能，大大降低了使用成本。</p><h5 id="实现“预绑定方法模式”"><a href="#实现“预绑定方法模式”" class="headerlink" title="实现“预绑定方法模式”"></a>实现“预绑定方法模式”</h5><p>虽然在处理全局配置对象时，单例模式是一种行之有效的解决方案，但在 Python 中，其实有一种更简单的做法——预绑定方法模式。</p><p><strong>预绑定方法模式</strong>（prebound method pattern）是一种将对象方法绑定为函数的模式。要实现该模式，第一步就是完全删掉 AppConfig 里的单例设计模式。因为在 Python 里，实现单例压根儿不用这么麻烦，我们有一个随手可得的单例对象——<strong>模块</strong>（module）。</p><p>当你在 Python 中执行 import 语句导入模块时，无论 import 执行了多少次，每个被导入的模块在内存中只会存在一份（保存在 sys.modules 中）。因此，要实现单例模式，只需在模块里创建一个全局对象即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>:</span></span><br><span class="line">    <span class="string">""" 程序配置类，使用单例模式 """</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 省略：从外部配置文件读取配置</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">_config = AppConfig()</span><br></pre></td></tr></table></figure><p>下一步，为了给其他模块提供好用的 API，我们需要将单例对象 _config 的公有方法绑定到 config 模块上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file: prokect/config.py</span></span><br><span class="line">_config = Config()</span><br><span class="line"></span><br><span class="line">get_database_conf = _config.get_database</span><br><span class="line">reload_config = _config.reload</span><br></pre></td></tr></table></figure><p>之后，其他模块就可以像调用普通函数一样操作应用配置对象了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> project.config <span class="keyword">import</span> get_database_conf</span><br><span class="line"></span><br><span class="line">db_conf = get_database_conf()</span><br><span class="line">reload_config()</span><br></pre></td></tr></table></figure><p>通过“预绑定方法模式”，我们既避免了复杂的单例设计模式，又有了更易使用的函数 API，可谓一举两得。</p><h2 id="第-10-章-面向对象设计原则（上）"><a href="#第-10-章-面向对象设计原则（上）" class="headerlink" title="第 10 章 面向对象设计原则（上）"></a>第 10 章 面向对象设计原则（上）</h2><p>《设计模式》中的大部分设计模式是作者用静态编程语言，在一个有着诸多限制的面向对象环境里创造出来的。而 Python 是一门动态到骨子里的编程语言，它有着一等函数对象、“鸭子类型”、可自定义的数据模型等各种灵活特性。因此，我们极少会用 Python 来一比一还原经典设计模式，而几乎总是会为每种设计模式找到更合适 Python 的表现形式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
